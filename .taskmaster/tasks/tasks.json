{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Hardhat Project and Configure Blockchain Infrastructure",
        "description": "Set up the base Hardhat development environment with Polygon Amoy testnet configuration, Alchemy integration, and project dependencies",
        "details": "Create a new Hardhat TypeScript project with the following configuration:\n1. Initialize project: `npx hardhat init` (TypeScript project)\n2. Install core dependencies: `@openzeppelin/contracts@^5.0.0`, `@nomicfoundation/hardhat-toolbox`, `@nomicfoundation/hardhat-verify`, `alchemy-sdk@^3.0.0`, `dotenv`\n3. Configure hardhat.config.ts with:\n   - Solidity 0.8.20 with optimizer (200 runs)\n   - Polygon Amoy network (chainId: 80002)\n   - Alchemy RPC endpoint configuration\n   - Polygonscan verification setup\n   - Gas reporter configuration\n4. Setup .env file with placeholders for ALCHEMY_API_KEY, DEPLOYER_PRIVATE_KEY, POLYGONSCAN_API_KEY\n5. Create project structure directories: contracts/, scripts/, test/, backend/, cli/, frontend/",
        "testStrategy": "Verify Hardhat compiles a sample contract successfully, test network connectivity to Alchemy Polygon Amoy endpoint, ensure environment variables are properly loaded",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Hardhat TypeScript project with basic structure",
            "description": "Create a new Hardhat project with TypeScript configuration and verify the basic project structure is properly set up",
            "dependencies": [],
            "details": "Execute `npx hardhat init` and select TypeScript project option. Verify that the project initializes with the standard Hardhat folder structure including contracts/, scripts/, test/ directories. Ensure the basic TypeScript configuration files (tsconfig.json, hardhat.config.ts) are created correctly. Test that the sample contract compiles successfully with `npx hardhat compile` to validate the initial setup.",
            "status": "done",
            "testStrategy": "Run `npx hardhat compile` to verify successful compilation, check that all expected directories and configuration files are present, ensure TypeScript is properly configured",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Install and configure all required dependencies",
            "description": "Install OpenZeppelin contracts, Hardhat toolbox, verification tools, Alchemy SDK, and other essential packages for the project",
            "dependencies": [
              1
            ],
            "details": "Install the following packages with exact versions: `npm install --save-dev @nomicfoundation/hardhat-toolbox @nomicfoundation/hardhat-verify dotenv` and `npm install @openzeppelin/contracts@^5.0.0 alchemy-sdk@^3.0.0`. Verify all packages are correctly listed in package.json with appropriate version constraints. Check that TypeScript types are properly resolved for all installed packages. Ensure no dependency conflicts exist and the project can still compile after installation.",
            "status": "done",
            "testStrategy": "Verify all packages are in package.json, run `npm list` to check for dependency conflicts, compile a sample contract importing OpenZeppelin to test integration",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configure hardhat.config.ts with networks and compiler settings",
            "description": "Set up the Hardhat configuration file with Polygon Amoy network, Solidity compiler settings, gas reporter, and verification plugins",
            "dependencies": [
              2
            ],
            "details": "Update hardhat.config.ts to include: Solidity compiler version 0.8.20 with optimizer enabled (200 runs), Polygon Amoy network configuration with chainId 80002 and Alchemy RPC endpoint placeholder, Polygonscan verification plugin setup with API key placeholder, gas reporter configuration for cost analysis. Import dotenv at the top of the config file to enable environment variable usage. Add proper TypeScript types for the configuration object. Ensure all network configurations use environment variables for sensitive data.",
            "status": "done",
            "testStrategy": "Test configuration loading without errors, verify network can be selected with `npx hardhat console --network polygon-amoy`, check compiler settings work with a test contract",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Setup environment variables and complete project directory structure",
            "description": "Create .env file with required API keys and private key placeholders, establish all project directories including backend, CLI, and frontend folders",
            "dependencies": [
              3
            ],
            "details": "Create .env file with placeholders: ALCHEMY_API_KEY, DEPLOYER_PRIVATE_KEY, POLYGONSCAN_API_KEY. Add .env to .gitignore to prevent accidental commits. Create .env.example with the same structure but dummy values for documentation. Create additional project directories: backend/, cli/, frontend/ at the root level. Add README.md files in each directory explaining their purpose. Verify that environment variables are properly loaded in hardhat.config.ts using process.env. Test that the configuration correctly reads from .env file.",
            "status": "done",
            "testStrategy": "Verify .env is in .gitignore, test environment variable loading in hardhat.config.ts, ensure all directories exist with proper structure, validate project compiles with env vars",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Initialize Hardhat TypeScript project with basic structure, 2) Install and configure dependencies (OpenZeppelin, Alchemy SDK, etc.), 3) Configure hardhat.config.ts with networks and compiler settings, 4) Setup environment variables and project directories"
      },
      {
        "id": 2,
        "title": "Develop ChainEquityToken Smart Contract",
        "description": "Implement the core ERC-20 token contract with allowlist-based transfer restrictions, virtual stock splits, and mutable symbol capabilities",
        "details": "Create ChainEquityToken.sol implementing:\n1. Inherit from OpenZeppelin ERC20 and Ownable\n2. State variables:\n   - `mapping(address => bool) public allowlist`\n   - `uint256 public splitMultiplier = 1`\n   - Mutable `_symbol` and `_name` storage\n3. Core functions:\n   - `approveWallet(address)` and `revokeWallet(address)` for allowlist management\n   - Override `_update()` to enforce allowlist checks on transfers\n   - `mint(address to, uint256 amount)` restricted to owner\n   - `executeSplit(uint256 multiplier)` for virtual stock splits\n   - `updateSymbol(string memory newSymbol)` for symbol changes\n   - Override `balanceOf()` and `totalSupply()` to multiply by splitMultiplier\n4. Events: WalletApproved, WalletRevoked, StockSplit, SymbolChanged, TransferBlocked\n5. Implement proper access control with onlyOwner modifiers",
        "testStrategy": "Write comprehensive unit tests covering: allowlist management, transfer restrictions (both approved/non-approved scenarios), minting functionality, stock split calculations maintaining ownership percentages, symbol changes, edge cases with zero balances and maximum uint256 values",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up smart contract structure with OpenZeppelin imports",
            "description": "Create the base ChainEquityToken.sol contract file with proper imports from OpenZeppelin, set up the contract structure inheriting from ERC20 and Ownable, and define all necessary state variables",
            "dependencies": [],
            "details": "Create contracts/ChainEquityToken.sol file. Import ERC20, Ownable from OpenZeppelin v5. Define contract ChainEquityToken inheriting both. Add state variables: mapping(address => bool) public allowlist, uint256 public splitMultiplier = 1, string private _customSymbol, string private _customName. Initialize constructor with name, symbol, and initial owner parameters. Set up basic contract structure with pragma solidity ^0.8.20",
            "status": "done",
            "testStrategy": "Unit tests to verify contract deployment, initial state variables are correctly set, ownership is assigned to deployer, and OpenZeppelin imports are working correctly",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement allowlist mechanism with approval and revocation functions",
            "description": "Build the complete allowlist management system including approveWallet and revokeWallet functions with proper access control and event emissions",
            "dependencies": [
              1
            ],
            "details": "Implement approveWallet(address wallet) function with onlyOwner modifier that sets allowlist[wallet] = true and emits WalletApproved event. Implement revokeWallet(address wallet) with onlyOwner that sets allowlist[wallet] = false and emits WalletRevoked event. Add isApproved(address wallet) view function returning allowlist status. Define events: WalletApproved(address indexed wallet), WalletRevoked(address indexed wallet). Add require statements to prevent duplicate approvals/revocations",
            "status": "done",
            "testStrategy": "Test approval and revocation of wallets, verify only owner can call these functions, test event emissions, validate duplicate approval/revocation prevention",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Override transfer functions to enforce allowlist restrictions",
            "description": "Override the ERC20 _update function to implement allowlist-based transfer restrictions, ensuring only approved addresses can send or receive tokens",
            "dependencies": [
              2
            ],
            "details": "Override _update(address from, address to, uint256 value) internal function from ERC20. Add logic to check if both from and to addresses are in allowlist (skip check for address(0) for minting/burning). If transfer violates allowlist, emit TransferBlocked event and revert with custom error. Define TransferBlocked event with from, to, amount parameters. Create custom error NotInAllowlist(address account). Ensure minting to non-allowlisted addresses is prevented",
            "status": "done",
            "testStrategy": "Test transfers between approved wallets succeed, transfers involving non-approved wallets fail, test minting restrictions, verify TransferBlocked events are emitted correctly",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement virtual stock split functionality with multiplier logic",
            "description": "Create the stock split mechanism that adjusts token balances virtually through a multiplier without changing actual stored values",
            "dependencies": [
              1
            ],
            "details": "Implement executeSplit(uint256 multiplier) function with onlyOwner modifier. Validate multiplier > 0 and != 1. Update splitMultiplier by multiplying current value with new multiplier. Override balanceOf(address account) to return super.balanceOf(account) * splitMultiplier. Override totalSupply() to return super.totalSupply() * splitMultiplier. Emit StockSplit event with multiplier and new splitMultiplier value. Add getSplitMultiplier() view function. Handle overflow checks using SafeMath or Solidity 0.8+ automatic checks",
            "status": "done",
            "testStrategy": "Test split execution with various multipliers, verify balance calculations after splits, test multiple consecutive splits, validate overflow protection, ensure proportional ownership is maintained",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add mutable symbol capability with update functions",
            "description": "Implement the ability to change the token symbol and name after deployment with proper access control and event logging",
            "dependencies": [
              1
            ],
            "details": "Override symbol() and name() functions to return _customSymbol and _customName if set, otherwise return default values. Implement updateSymbol(string memory newSymbol) with onlyOwner modifier, validate newSymbol is not empty, update _customSymbol and emit SymbolChanged event. Implement updateName(string memory newName) similarly for token name. Define SymbolChanged event with oldSymbol and newSymbol parameters. Add getters for current symbol and name. Ensure symbol length validation (typically 3-11 characters)",
            "status": "done",
            "testStrategy": "Test symbol and name updates, verify only owner can update, test empty string validation, verify event emissions, test symbol() and name() return correct values",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create mint function and comprehensive error handling",
            "description": "Implement the minting functionality restricted to owner and add comprehensive error handling with custom errors and proper event emissions throughout the contract",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Implement mint(address to, uint256 amount) public onlyOwner function that calls _mint(to, amount). Ensure minting respects allowlist restrictions through _update override. Define all custom errors: InvalidMultiplier(), InvalidSymbol(), ZeroAddress(), ZeroAmount(). Add require statements with descriptive messages throughout all functions. Implement proper natspec documentation for all public/external functions. Add fallback and receive functions if needed. Ensure all state-changing functions emit appropriate events for off-chain indexing",
            "status": "done",
            "testStrategy": "Test minting with valid and invalid parameters, verify all custom errors are thrown correctly, test edge cases with zero amounts and addresses, validate all events are emitted with correct parameters",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down into: 1) Create base ERC20 structure with OpenZeppelin imports, 2) Implement allowlist mechanism with approval/revocation functions, 3) Override transfer functions to enforce allowlist restrictions, 4) Implement virtual stock split functionality with multiplier logic, 5) Add mutable symbol capability with proper events, 6) Create comprehensive events and error handling"
      },
      {
        "id": 3,
        "title": "Backend Services Foundation and Database Setup",
        "description": "Establish the Node.js/TypeScript backend infrastructure with Express API server, SQLite database, and Alchemy SDK integration",
        "details": "Setup backend services:\n1. Initialize backend/ directory with TypeScript configuration\n2. Install dependencies: `express`, `better-sqlite3`, `alchemy-sdk`, `typescript`, `@types/*`\n3. Create SQLite database schema (schema.sql):\n   - events table (block_number, transaction_hash, event_type, from_address, to_address, amount, data JSON, timestamp)\n   - balances table (address, balance, last_updated_block, last_updated_timestamp)\n   - corporate_actions table (action_type, block_number, transaction_hash, old_value, new_value, timestamp)\n4. Implement database.ts with connection management and prepared statements\n5. Setup Alchemy SDK configuration (alchemy.config.ts) with WebSocket support\n6. Create Express server.ts with basic routing structure\n7. Implement TypeScript interfaces for all data models",
        "testStrategy": "Test database CRUD operations, verify SQLite schema creation, test Alchemy SDK connection to Polygon Amoy, ensure Express server starts correctly with proper middleware configuration",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize TypeScript backend project with proper configuration",
            "description": "Set up the backend directory structure with TypeScript, Node.js configuration, and install all required dependencies for the Express server and database integration",
            "dependencies": [],
            "details": "Create backend/ directory with proper folder structure (src/, dist/, tests/). Initialize package.json with npm init. Install core dependencies: express, typescript, @types/node, @types/express, ts-node, nodemon for development. Create tsconfig.json with strict mode, ES2020 target, and proper module resolution. Setup .env file structure for configuration variables. Configure build and dev scripts in package.json.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation works, ensure all dependencies are installed correctly, test that npm scripts run without errors",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Design and implement SQLite database schema with all tables",
            "description": "Create the complete database schema including events, balances, and corporate_actions tables with proper indexes and constraints",
            "dependencies": [
              1
            ],
            "details": "Install better-sqlite3 and @types/better-sqlite3. Create schema.sql file with three tables: events table with columns for block_number (INTEGER), transaction_hash (TEXT PRIMARY KEY), event_type (TEXT), from_address (TEXT), to_address (TEXT), amount (TEXT), data (JSON), timestamp (INTEGER). Create balances table with address (TEXT PRIMARY KEY), balance (TEXT), last_updated_block (INTEGER), last_updated_timestamp (INTEGER). Create corporate_actions table with action_type (TEXT), block_number (INTEGER), transaction_hash (TEXT), old_value (TEXT), new_value (TEXT), timestamp (INTEGER). Add appropriate indexes for query performance.",
            "status": "done",
            "testStrategy": "Test schema creation with sample data insertion, verify all constraints work correctly, test index performance with query execution plans",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create database connection layer with Better-SQLite3",
            "description": "Implement the database service layer with connection management, prepared statements, and transaction support for all database operations",
            "dependencies": [
              2
            ],
            "details": "Create database.ts file with Database class implementing singleton pattern for connection management. Implement prepared statements for all CRUD operations: insertEvent(), updateBalance(), getBalance(), getEvents(), insertCorporateAction(). Add transaction support with begin(), commit(), rollback() methods. Implement database initialization method that runs schema.sql on first startup. Add connection pooling and error handling with automatic retry logic. Create TypeScript interfaces for all database models (Event, Balance, CorporateAction).",
            "status": "done",
            "testStrategy": "Unit tests for all database methods, test transaction rollback scenarios, verify prepared statement performance, test connection recovery after database errors",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Setup Express server with middleware and basic routing",
            "description": "Configure Express server with essential middleware, error handling, and establish the basic routing structure for the API endpoints",
            "dependencies": [
              1
            ],
            "details": "Create server.ts with Express application setup. Configure middleware stack: cors for cross-origin requests, helmet for security headers, express.json() for JSON parsing, morgan for request logging. Implement global error handler middleware with proper error response formatting. Setup route structure with separate route files for /api/issuer, /api/corporate, /api/captable endpoints. Configure server to listen on configurable port from environment variables. Add health check endpoint at /health. Implement graceful shutdown handling for SIGTERM/SIGINT signals.",
            "status": "done",
            "testStrategy": "Test server startup and shutdown, verify all middleware is working correctly, test error handling with various error scenarios, validate CORS configuration",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configure Alchemy SDK with WebSocket support",
            "description": "Set up Alchemy SDK configuration for Polygon Amoy network with WebSocket connections for real-time event monitoring",
            "dependencies": [
              1
            ],
            "details": "Install alchemy-sdk and ethers dependencies. Create alchemy.config.ts with AlchemySettings configuration for Polygon Amoy network. Configure WebSocket provider for real-time event subscriptions. Set up authentication with Alchemy API key from environment variables. Implement connection management with automatic reconnection logic for WebSocket disconnections. Create helper functions for converting between different unit formats (wei, ether). Setup contract ABI interfaces for the token contract. Implement retry logic with exponential backoff for failed RPC calls.",
            "status": "done",
            "testStrategy": "Test connection to Alchemy Polygon Amoy network, verify WebSocket subscription works, test reconnection after network interruption, validate contract interaction methods",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Initialize TypeScript backend project with proper configuration, 2) Design and implement SQLite database schema with all tables, 3) Create database connection layer with Better-SQLite3, 4) Setup Express server with middleware and basic routing, 5) Configure Alchemy SDK with WebSocket support"
      },
      {
        "id": 4,
        "title": "Implement Issuer Service for Token Management",
        "description": "Build the core service responsible for wallet approvals, token minting, and executing corporate actions through smart contract interactions",
        "details": "Create issuer.service.ts with:\n1. Initialize Alchemy SDK client and contract instance with signer\n2. Wallet management methods:\n   - `approveWallet(address)`: Submit approval transaction\n   - `revokeWallet(address)`: Submit revocation transaction\n   - `isWalletApproved(address)`: Query allowlist status\n   - `getApprovedWallets()`: Return all approved addresses\n3. Token operations:\n   - `mintTokens(to, amount)`: Mint with proper unit conversion\n   - Gas estimation for all operations\n4. Corporate actions:\n   - `executeSplit(multiplier)`: Trigger stock split\n   - `updateSymbol(newSymbol)`: Change token symbol\n5. Transaction management:\n   - Wait for confirmations\n   - Return formatted transaction receipts\n   - Error handling with retry logic",
        "testStrategy": "Integration tests for end-to-end wallet approval and minting flow, verify gas estimation accuracy, test transaction failure scenarios and retry mechanisms, validate corporate action execution",
        "priority": "high",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create IssuerService class with Alchemy SDK initialization",
            "description": "Set up the IssuerService class structure with constructor, Alchemy SDK client initialization, and contract instance binding with proper signer configuration",
            "dependencies": [],
            "details": "Create issuer.service.ts file with IssuerService class. Initialize Alchemy SDK with network configuration for Polygon Amoy. Set up contract instance using ABI and deployed address from config. Configure wallet/signer for transaction signing. Implement constructor to accept configuration parameters and establish connection to blockchain.",
            "status": "done",
            "testStrategy": "Unit tests to verify Alchemy SDK initialization, mock contract instance creation, test configuration parameter handling",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement wallet management methods for allowlist control",
            "description": "Build the wallet management functionality including approve, revoke, and query operations for the allowlist system",
            "dependencies": [
              1
            ],
            "details": "Implement approveWallet(address) method to submit approval transaction to smart contract. Create revokeWallet(address) for removing addresses from allowlist. Build isWalletApproved(address) to query current approval status. Implement getApprovedWallets() to retrieve all approved addresses from contract events or state. Add proper type checking and address validation.",
            "status": "done",
            "testStrategy": "Integration tests for wallet approval/revocation flow, mock contract calls, verify address validation and error handling",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build token minting functionality with gas estimation",
            "description": "Develop the token minting operations including proper unit conversion, gas estimation, and transaction submission",
            "dependencies": [
              1
            ],
            "details": "Implement mintTokens(to, amount) method with proper decimal conversion based on token decimals. Add gas estimation logic using estimateGas() before transaction submission. Implement dynamic gas price fetching for optimal transaction costs. Handle unit conversion between user input and blockchain representation. Add validation for minting permissions and amount limits.",
            "status": "done",
            "testStrategy": "Test minting with various amounts, verify gas estimation accuracy, test decimal conversion edge cases, validate permission checks",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add corporate action methods for splits and symbol changes",
            "description": "Implement methods for executing corporate actions including stock splits and token symbol updates",
            "dependencies": [
              1
            ],
            "details": "Create executeSplit(multiplier) method to trigger stock split transactions with proper validation of multiplier values. Implement updateSymbol(newSymbol) for changing token symbol on-chain. Add validation for symbol format and length restrictions. Include event emission tracking for corporate actions. Implement proper authorization checks to ensure only authorized addresses can execute these actions.",
            "status": "done",
            "testStrategy": "Test split execution with various multipliers, verify symbol update constraints, test authorization failures, validate event emissions",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement transaction management with retry logic and error handling",
            "description": "Build robust transaction management system with confirmation waiting, retry mechanism for failed transactions, and comprehensive error handling",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement transaction submission wrapper with configurable confirmation blocks. Add retry logic with exponential backoff for failed transactions. Create formatted transaction receipt return objects with relevant data. Implement comprehensive error handling for common Web3 errors like insufficient gas, network issues, and reverted transactions. Add transaction status monitoring and timeout handling. Include logging for transaction lifecycle events.",
            "status": "done",
            "testStrategy": "Test retry logic with simulated failures, verify timeout handling, test various error scenarios, validate transaction receipt formatting",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Create service class with Alchemy SDK initialization and contract binding, 2) Implement wallet management methods (approve/revoke/query), 3) Build token minting functionality with gas estimation, 4) Add corporate action methods (split/symbol change), 5) Implement transaction management with retry logic and error handling"
      },
      {
        "id": 5,
        "title": "Build Event Indexer Service with Real-time Processing",
        "description": "Develop the blockchain event listener that processes Transfer, Approval, and Corporate Action events in real-time and maintains the local database state",
        "details": "Implement indexer.service.ts:\n1. WebSocket connection to Alchemy for real-time events\n2. Event listeners for:\n   - Transfer events: Update sender/recipient balances\n   - WalletApproved/Revoked: Track allowlist changes\n   - StockSplit: Record multiplier changes\n   - SymbolChanged: Log symbol updates\n3. Event processing pipeline:\n   - Parse event logs with proper ABI decoding\n   - Store in events table with full metadata\n   - Update balances table atomically\n   - Handle blockchain reorganizations\n4. Historical indexing:\n   - `reindexFromBlock(blockNumber)` for catching up\n   - Batch processing for efficiency\n5. Monitoring:\n   - Health checks for WebSocket connection\n   - Auto-reconnect on disconnection\n   - Event processing metrics",
        "testStrategy": "Test real-time event capture, verify balance calculations match on-chain state, test reorganization handling, validate historical reindexing accuracy, stress test with high event volume",
        "priority": "medium",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup WebSocket connection with Alchemy for real-time monitoring",
            "description": "Establish and configure WebSocket connection to Alchemy for real-time blockchain event monitoring with automatic reconnection and health checks",
            "dependencies": [],
            "details": "Initialize Alchemy SDK WebSocket provider in indexer.service.ts. Configure connection parameters including network (Polygon Amoy), API key, and WebSocket options. Implement connection state management with automatic reconnection logic on disconnection. Add health check monitoring to track connection status and emit events on connection state changes. Set up error handlers for WebSocket failures and implement exponential backoff for reconnection attempts.",
            "status": "done",
            "testStrategy": "Test WebSocket connection establishment, simulate disconnections and verify auto-reconnect, test health check responses, verify connection state events",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement event listeners for all smart contract events",
            "description": "Create event listeners for Transfer, WalletApproved, WalletRevoked, StockSplit, and SymbolChanged events with proper filtering and subscription management",
            "dependencies": [
              1
            ],
            "details": "Set up event filters for each event type using contract ABI definitions. Implement listeners for Transfer events to track balance changes, WalletApproved/WalletRevoked for allowlist updates, StockSplit for multiplier tracking, and SymbolChanged for symbol updates. Configure event filters with proper topics and address filtering. Manage subscriptions lifecycle and ensure proper cleanup on service shutdown. Add event queueing mechanism to handle burst traffic.",
            "status": "done",
            "testStrategy": "Test each event listener with mock events, verify filter configurations, test subscription management, simulate high event volume scenarios",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create event processing pipeline with ABI decoding",
            "description": "Build robust event processing pipeline that decodes raw logs using contract ABI, validates event data, and transforms events into structured database records",
            "dependencies": [
              2
            ],
            "details": "Implement ABI decoder using ethers.js or web3.js to parse raw event logs. Create event processor classes for each event type with validation logic. Build pipeline stages: raw log reception, ABI decoding, data validation, transformation to database schema, and error handling. Add event deduplication to prevent duplicate processing. Implement event ordering to ensure sequential processing within same block. Add metrics collection for processing performance.",
            "status": "done",
            "testStrategy": "Test ABI decoding with various event types, verify data transformation accuracy, test deduplication logic, validate sequential processing",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build database update logic for balances and events",
            "description": "Implement atomic database operations to update balances table and store events with full metadata, ensuring data consistency and transaction integrity",
            "dependencies": [
              3
            ],
            "details": "Create database transaction handlers for atomic updates to balances and events tables. Implement balance calculation logic that accounts for transfers and maintains running totals. Store complete event metadata including block number, transaction hash, timestamp, and decoded parameters. Build batch insert operations for efficiency during historical indexing. Implement database triggers or constraints to ensure data integrity. Add indexes on frequently queried fields for performance optimization.",
            "status": "done",
            "testStrategy": "Test atomic transaction handling, verify balance calculations match on-chain state, test batch operations performance, validate data integrity constraints",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement blockchain reorganization handling",
            "description": "Build mechanisms to detect and handle blockchain reorganizations by rolling back affected database state and reprocessing blocks",
            "dependencies": [
              4
            ],
            "details": "Implement block confirmation tracking to detect potential reorganizations. Create rollback mechanism to revert database state to last stable block when reorg detected. Track uncle blocks and monitor for chain switches. Implement reprocessing logic to re-index affected blocks after reorganization. Store block hashes to verify chain continuity. Add configurable confirmation threshold before considering blocks finalized. Implement alerting for significant reorganization events.",
            "status": "done",
            "testStrategy": "Simulate blockchain reorganizations and verify correct rollback, test reprocessing accuracy, validate chain continuity checks",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Add historical indexing with batch processing capabilities",
            "description": "Develop efficient batch processing system for indexing historical blockchain data with configurable block ranges and performance optimization",
            "dependencies": [
              4,
              5
            ],
            "details": "Implement reindexFromBlock(blockNumber) method for catching up from specific block. Create batch fetching logic to retrieve multiple blocks in single RPC calls. Build parallel processing pipeline for historical events while maintaining order. Implement progress tracking and resumable indexing on interruption. Add rate limiting to prevent API throttling. Create block range chunking for memory-efficient processing. Implement checkpointing to save progress periodically. Add performance metrics for indexing speed.",
            "status": "done",
            "testStrategy": "Test batch processing with large block ranges, verify resumable indexing after interruption, test rate limiting effectiveness, validate historical data accuracy",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down into: 1) Setup WebSocket connection with Alchemy for real-time event monitoring, 2) Implement event listeners for all contract events, 3) Create event processing pipeline with ABI decoding, 4) Build database update logic for balances and events, 5) Implement blockchain reorganization handling, 6) Add historical indexing with batch processing capabilities"
      },
      {
        "id": 6,
        "title": "Create Cap-Table Service for Ownership Analytics",
        "description": "Implement the service that generates real-time and historical cap-table snapshots with ownership percentages and export capabilities",
        "details": "Build captable.service.ts:\n1. Core cap-table generation:\n   - `generateCapTable(blockNumber?)`: Query balances at specific block\n   - Calculate ownership percentages\n   - Account for split multipliers correctly\n   - Sort by balance descending\n2. Export functionality:\n   - `exportToCSV()`: Format with headers (Address, Balance, Ownership %, Last Updated)\n   - `exportToJSON()`: Structured JSON with metadata\n3. Analytics methods:\n   - `getHolderCount()`: Total unique holders\n   - `getTotalSupply()`: Accounting for splits\n   - `getOwnershipDistribution()`: Statistical analysis\n   - `getTopHolders(limit)`: Largest holders\n4. Historical queries:\n   - Point-in-time cap-table reconstruction\n   - Balance changes over time\n5. Performance optimization with indexed queries",
        "testStrategy": "Verify cap-table calculations match on-chain data, test CSV/JSON export formats, validate historical queries against known states, test with various split multipliers",
        "priority": "medium",
        "dependencies": [
          "3",
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement core cap-table generation with ownership calculations",
            "description": "Create the foundational cap-table generation logic that queries balances, calculates ownership percentages, and handles split multipliers correctly",
            "dependencies": [],
            "details": "Implement captable.service.ts with generateCapTable(blockNumber?) method that queries the balances table at a specific block height, retrieves total supply accounting for splits, calculates ownership percentages for each holder, properly applies split multipliers to balances, and sorts results by balance in descending order. Include proper TypeScript interfaces for cap-table entries and ensure accurate decimal handling for percentage calculations.",
            "status": "done",
            "testStrategy": "Unit test cap-table generation with mock balance data, verify ownership percentage calculations sum to 100%, test with various split multiplier scenarios, validate sorting logic",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add CSV and JSON export functionality for cap-table data",
            "description": "Implement export methods that format cap-table data into CSV and JSON formats with appropriate headers and metadata",
            "dependencies": [
              1
            ],
            "details": "Add exportToCSV() method that generates CSV with headers (Address, Balance, Ownership %, Last Updated), properly escapes values, and handles large decimal numbers. Implement exportToJSON() that creates structured JSON with metadata including generation timestamp, block number, total supply, and holder count. Both methods should work with the cap-table data structure from generateCapTable() and handle edge cases like empty cap-tables.",
            "status": "done",
            "testStrategy": "Test CSV export format compliance and proper escaping, validate JSON structure and metadata accuracy, test with empty and large cap-tables",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build analytics methods for holder statistics and distribution analysis",
            "description": "Create analytical functions that provide insights into token holder distribution, concentration metrics, and statistical analysis",
            "dependencies": [
              1
            ],
            "details": "Implement getHolderCount() to return total unique holders, getTotalSupply() that correctly accounts for split multipliers, getOwnershipDistribution() that calculates statistical metrics like Gini coefficient and concentration ratios, and getTopHolders(limit) that returns the largest holders with their ownership percentages. Include methods for calculating median holding, average holding, and standard deviation of holdings.",
            "status": "done",
            "testStrategy": "Verify holder count matches database records, test total supply calculation with splits, validate statistical calculations against known distributions, test top holders query performance",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement historical cap-table queries with point-in-time reconstruction",
            "description": "Enable querying of historical cap-table states at any past block number with efficient database queries and caching",
            "dependencies": [
              1
            ],
            "details": "Extend generateCapTable() to support historical block queries using the events table to reconstruct balances at any point in time. Implement getBalanceChanges(address, fromBlock, toBlock) to track balance evolution over time. Add caching layer for frequently queried historical states. Ensure queries are optimized with proper database indexes on block_number and address fields. Handle edge cases like querying before token deployment.",
            "status": "done",
            "testStrategy": "Test historical reconstruction against known past states, verify balance changes match event logs, test query performance with large datasets, validate caching behavior",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Implement core cap-table generation with ownership percentage calculations, 2) Add export functionality for CSV and JSON formats, 3) Build analytics methods for holder statistics and distribution, 4) Implement historical cap-table queries with point-in-time reconstruction"
      },
      {
        "id": 7,
        "title": "Develop CLI Tool for Operator Interactions",
        "description": "Create a comprehensive command-line interface for all token management operations with colored output and user-friendly formatting",
        "details": "Implement CLI with Commander.js:\n1. Project structure:\n   - cli/index.ts: Main entry point with command registration\n   - cli/commands/: Individual command files\n   - cli/utils/: Formatting and validation helpers\n2. Commands to implement:\n   - Wallet: `approve`, `revoke`, `status`, `list-approved`\n   - Token: `mint`, `transfer`, `balance`\n   - Corporate: `split`, `symbol`\n   - Cap-table: `captable` with --block and --format options\n   - Utilities: `deploy`, `verify`, `demo`\n3. Features:\n   - Colored output with chalk\n   - Table formatting with cli-table3\n   - Input validation and error handling\n   - Progress indicators for long operations\n   - Transaction confirmation prompts\n4. Configuration:\n   - Read from .env for network settings\n   - Support multiple networks (local, amoy)",
        "testStrategy": "Test each command with valid and invalid inputs, verify transaction submission and confirmation, test output formatting and error messages, validate CSV/JSON exports from CLI",
        "priority": "medium",
        "dependencies": [
          "4",
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup Commander.js project structure with TypeScript configuration",
            "description": "Initialize the CLI project structure with Commander.js framework, TypeScript setup, and establish the command registration architecture",
            "dependencies": [],
            "details": "Create cli/ directory with index.ts as main entry point. Setup TypeScript configuration for CLI module. Install Commander.js, chalk for colored output, cli-table3 for formatted tables, and inquirer for prompts. Implement base command structure with program.name('chainequity').version('1.0.0').description(). Create commands/ and utils/ subdirectories. Setup command registration pattern that dynamically loads all command files from commands/ directory. Configure tsconfig.json for CLI with proper module resolution.",
            "status": "done",
            "testStrategy": "Test CLI initialization and help command output, verify TypeScript compilation, test command registration mechanism",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement wallet management commands with allowlist operations",
            "description": "Create wallet-related commands for managing approved addresses including approve, revoke, status checking, and listing all approved wallets",
            "dependencies": [
              1
            ],
            "details": "Implement cli/commands/wallet.ts with four subcommands. Create 'approve <address>' command that calls contract.approveWallet() with validation for valid Ethereum addresses. Build 'revoke <address>' command for removing wallet approval. Add 'status <address>' to check if specific address is approved. Implement 'list-approved' to fetch and display all approved addresses in a formatted table. Add transaction confirmation prompts before executing approve/revoke. Include proper error handling for invalid addresses and failed transactions. Use chalk for success (green) and error (red) messages.",
            "status": "done",
            "testStrategy": "Test address validation for all commands, verify transaction submission and confirmation flow, test table formatting for list output",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create token operation commands for minting and transfers",
            "description": "Build commands for core token operations including minting new tokens, transferring between addresses, and checking balances",
            "dependencies": [
              1
            ],
            "details": "Create cli/commands/token.ts with mint, transfer, and balance subcommands. Implement 'mint <to> <amount>' with owner-only validation and amount parsing (supporting decimal notation). Build 'transfer <to> <amount>' with allowlist checking before submission. Add 'balance <address>' to query and display token balance with proper formatting (commas for thousands). Include --wei flag for raw values without decimals conversion. Add progress indicators using ora spinner for transaction mining. Implement proper error messages for insufficient balance, unauthorized minting attempts, and non-allowlisted transfers.",
            "status": "done",
            "testStrategy": "Test amount parsing and validation, verify decimal/wei conversion accuracy, test error handling for restricted operations",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add corporate action commands for splits and symbol changes",
            "description": "Implement corporate action commands to handle stock splits and symbol changes with proper formatting and user confirmation",
            "dependencies": [
              1
            ],
            "details": "Create cli/commands/corporate.ts with split and symbol subcommands. Implement 'split <multiplier>' command that executes stock split with validation for positive integers. Add confirmation prompt showing impact (e.g., '1 token will become X tokens'). Build 'symbol <new-symbol>' command with validation for valid token symbols (3-5 uppercase characters). Add 'captable' command with --block flag for historical queries and --format option (table/csv/json). Implement CSV and JSON export functionality using fs.writeFileSync. Format cap-table with ownership percentages and proper number formatting. Include total supply and holder count in output.",
            "status": "done",
            "testStrategy": "Test multiplier validation and calculation display, verify symbol validation rules, test all export formats for cap-table data",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Build utility commands with configuration and demo mode",
            "description": "Create utility commands for contract deployment, verification, configuration management, and a comprehensive demo mode showcasing all features",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement cli/commands/utils.ts with deploy, verify, and demo commands. Create 'deploy' command that deploys new contract instance with initial parameters. Build 'verify <address>' to verify contract on Polygonscan using hardhat-verify. Add 'demo' command that runs through all CLI features in sequence with sample data. Create cli/utils/config.ts to read .env file for RPC URLs and private keys. Support --network flag (local/amoy/polygon) for all commands. Implement cli/utils/formatter.ts with formatAddress(), formatAmount(), and formatTable() helpers. Add comprehensive error handling with detailed messages and recovery suggestions.",
            "status": "done",
            "testStrategy": "Test network switching functionality, verify demo mode executes all commands successfully, test configuration loading from .env",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Setup Commander.js project structure with command registration, 2) Implement wallet management commands (approve/revoke/status), 3) Create token operation commands (mint/transfer/balance), 4) Add corporate action commands (split/symbol), 5) Build utility commands with formatted output and error handling"
      },
      {
        "id": 8,
        "title": "Contract Deployment and Verification Scripts",
        "description": "Create deployment automation scripts for local and Polygon Amoy networks with Polygonscan verification",
        "details": "Develop deployment infrastructure:\n1. scripts/deploy.ts:\n   - Deploy ChainEquityToken with initial parameters\n   - Store deployed address in .env\n   - Log deployment details (address, block, gas used)\n   - Support for different networks via --network flag\n2. scripts/verify.ts:\n   - Automated Polygonscan verification\n   - Constructor argument encoding\n   - Retry logic for verification API\n3. scripts/demo-flow.ts:\n   - Automated demonstration script\n   - Deploy contract\n   - Approve 3 test wallets\n   - Mint initial tokens\n   - Execute transfers (success and failure cases)\n   - Perform 7-for-1 stock split\n   - Change symbol\n   - Export cap-table at each stage\n4. scripts/setup-local.ts:\n   - Initialize local Hardhat node\n   - Fund test accounts\n   - Deploy contracts for development",
        "testStrategy": "Test deployment to local network, verify contract on testnet block explorer, run complete demo flow end-to-end, validate gas consumption meets targets",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create main deployment script with network configuration",
            "description": "Develop the primary deployment script (scripts/deploy.ts) that handles ChainEquityToken deployment across different networks with proper configuration and logging",
            "dependencies": [],
            "details": "Implement deploy.ts script with: 1) Network detection using Hardhat runtime environment, 2) Constructor parameter configuration for ChainEquityToken (name, symbol, initial supply), 3) Deployment transaction execution with gas estimation, 4) Deployed address storage in .env file using fs operations, 5) Comprehensive logging of deployment details including contract address, transaction hash, block number, gas used, and network name, 6) Support for --network flag to deploy to local/amoy/mainnet, 7) Error handling for failed deployments with rollback suggestions",
            "status": "done",
            "testStrategy": "Test deployment on local Hardhat network first, verify contract address is saved to .env, check deployment logs contain all required information, deploy to Amoy testnet and verify transaction on Polygonscan",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Polygonscan verification script with retry logic",
            "description": "Build the verification script (scripts/verify.ts) to automatically verify deployed contracts on Polygonscan with robust error handling and retry mechanisms",
            "dependencies": [
              1
            ],
            "details": "Create verify.ts script featuring: 1) Read deployed contract address from .env file, 2) Encode constructor arguments matching deployment parameters, 3) Submit verification request to Polygonscan API using hardhat-verify plugin, 4) Implement exponential backoff retry logic (3 attempts with 5/10/20 second delays), 5) Handle common verification errors (already verified, pending verification, rate limits), 6) Support for different network explorers (Polygonscan for Amoy/mainnet), 7) Verbose logging of verification status and response, 8) Option to verify specific contract by address parameter",
            "status": "done",
            "testStrategy": "Deploy contract to Amoy and run verification, test retry logic by simulating API failures, verify contract shows as verified on Polygonscan explorer, test with already verified contract",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build comprehensive demo flow script for testing",
            "description": "Create an automated demonstration script (scripts/demo-flow.ts) that showcases all ChainEquityToken features in a single execution flow with cap-table exports",
            "dependencies": [
              1
            ],
            "details": "Develop demo-flow.ts implementing: 1) Deploy new ChainEquityToken instance or use existing from .env, 2) Approve 3 test wallets using approveWallet function, 3) Mint initial tokens (10000 to wallet1, 5000 to wallet2, 2500 to wallet3), 4) Execute successful transfers between approved wallets, 5) Attempt and catch failed transfer from non-approved wallet, 6) Perform 7-for-1 stock split and verify balances multiplied correctly, 7) Change token symbol from CEQ to CEQX, 8) Export cap-table snapshots after each major operation to JSON files, 9) Generate summary report of all operations with gas costs, 10) Clean error handling with transaction details",
            "status": "done",
            "testStrategy": "Run complete demo flow on local network, verify all operations complete successfully, check cap-table exports are accurate at each stage, validate gas consumption is within expected ranges, test failure scenarios work correctly",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add local setup script for development environment",
            "description": "Create a development environment initialization script (scripts/setup-local.ts) that prepares a local Hardhat node with funded accounts and deployed contracts",
            "dependencies": [],
            "details": "Implement setup-local.ts with: 1) Start local Hardhat node programmatically or connect to existing node, 2) Generate or use predefined test accounts with private keys, 3) Fund test accounts with ETH from account[0] (10 ETH each for gas), 4) Deploy ChainEquityToken contract to local network, 5) Pre-approve 5 test wallets for immediate testing, 6) Mint initial token distribution (configurable amounts), 7) Save all addresses and private keys to .env.local file, 8) Display setup summary with account addresses, balances, and contract address, 9) Option to reset/clean existing local setup, 10) Watch mode to keep node running for development",
            "status": "done",
            "testStrategy": "Verify local node starts successfully, check all test accounts receive ETH funding, confirm contract deploys and test wallets are approved, validate .env.local contains correct information",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create main deployment script with network configuration, 2) Implement Polygonscan verification script with retry logic, 3) Build demo flow script for comprehensive testing, 4) Add local setup script for development environment"
      },
      {
        "id": 9,
        "title": "REST API Endpoints and Express Routes",
        "description": "Implement comprehensive REST API with proper error handling, input validation, and response formatting",
        "details": "Create Express API routes:\n1. Issuer endpoints (api/routes.ts):\n   - POST /api/issuer/approve\n   - POST /api/issuer/revoke  \n   - GET /api/issuer/status/:address\n   - GET /api/issuer/approved\n   - POST /api/issuer/mint\n2. Corporate actions:\n   - POST /api/corporate/split\n   - POST /api/corporate/symbol\n   - GET /api/corporate/history\n3. Cap-table endpoints:\n   - GET /api/captable\n   - GET /api/captable/:blockNumber\n   - GET /api/captable/export?format=csv|json\n4. Analytics:\n   - GET /api/analytics/holders\n   - GET /api/analytics/supply\n   - GET /api/analytics/distribution\n5. Middleware:\n   - Request validation\n   - Error handling\n   - CORS configuration\n   - Rate limiting\n   - Response formatting",
        "testStrategy": "API integration tests for all endpoints, test error responses and validation, verify CORS and rate limiting, load test critical endpoints",
        "priority": "medium",
        "dependencies": [
          "3",
          "4",
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement issuer management endpoints",
            "description": "Create Express routes for wallet approval/revocation and status checking with proper request validation and response formatting",
            "dependencies": [],
            "details": "Implement POST /api/issuer/approve, POST /api/issuer/revoke, GET /api/issuer/status/:address, GET /api/issuer/approved, and POST /api/issuer/mint endpoints. Each endpoint should validate input parameters, call the issuer service methods, handle errors appropriately, and return standardized JSON responses. Include request body validation using express-validator or joi for POST endpoints.",
            "status": "done",
            "testStrategy": "Write integration tests using supertest to verify each endpoint's functionality, test input validation rules, error responses for invalid data, and successful responses with correct status codes",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create corporate action endpoints",
            "description": "Build REST API routes for corporate actions including stock splits, symbol changes, and history retrieval with proper authorization",
            "dependencies": [
              1
            ],
            "details": "Implement POST /api/corporate/split for executing stock splits, POST /api/corporate/symbol for changing token symbols, and GET /api/corporate/history for retrieving corporate action history. Ensure proper authorization checks, validate split ratios and symbol formats, implement pagination for history endpoint, and return formatted responses with action confirmation details.",
            "status": "done",
            "testStrategy": "Test corporate action endpoints with valid and invalid inputs, verify authorization middleware works correctly, test history pagination, and validate response formats match API specifications",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build cap-table and export endpoints",
            "description": "Develop endpoints for retrieving cap-table data at specific blocks and exporting in multiple formats (CSV/JSON)",
            "dependencies": [
              1
            ],
            "details": "Create GET /api/captable for current cap-table, GET /api/captable/:blockNumber for historical snapshots, and GET /api/captable/export with format query parameter supporting CSV and JSON exports. Implement efficient database queries, handle large datasets with streaming responses, format CSV output with proper headers, and include ownership percentage calculations in responses.",
            "status": "done",
            "testStrategy": "Test cap-table retrieval at different block heights, verify CSV and JSON export formats are correct, test performance with large holder counts, validate ownership percentage calculations",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add analytics endpoints",
            "description": "Implement analytics API routes for holder statistics, token supply metrics, and distribution analysis",
            "dependencies": [
              3
            ],
            "details": "Build GET /api/analytics/holders for holder count and concentration metrics, GET /api/analytics/supply for total supply and circulating supply data, and GET /api/analytics/distribution for token distribution analysis including whale detection and decentralization metrics. Cache frequently requested analytics data, implement efficient aggregation queries, and return visualizable data formats.",
            "status": "done",
            "testStrategy": "Verify analytics calculations match on-chain data, test caching mechanisms, validate distribution metrics accuracy, test endpoint performance under load",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Setup middleware for validation, error handling, and CORS",
            "description": "Configure Express middleware stack including request validation, centralized error handling, CORS policy, rate limiting, and response formatting",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement validation middleware using express-validator for request body/params/query validation, create centralized error handler with proper status codes and error messages, configure CORS for allowed origins, add rate limiting using express-rate-limit to prevent abuse, implement response formatter for consistent API responses, add request logging middleware for debugging, and setup helmet for security headers.",
            "status": "done",
            "testStrategy": "Test rate limiting triggers correctly, verify CORS headers are set properly, test error handler catches all error types, validate security headers are present, test request validation middleware blocks invalid inputs",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Implement issuer management endpoints, 2) Create corporate action endpoints, 3) Build cap-table and export endpoints, 4) Add analytics endpoints, 5) Setup middleware for validation, error handling, and CORS"
      },
      {
        "id": 10,
        "title": "Comprehensive Testing Suite and Documentation",
        "description": "Write unit tests, integration tests, gas benchmarks, and complete technical documentation for the entire system",
        "details": "Complete testing and documentation:\n1. Unit tests (test/unit/):\n   - ChainEquityToken.test.ts: 100% contract coverage\n   - Test allowlist, transfers, minting, splits, symbol changes\n   - Edge cases and security scenarios\n2. Integration tests (test/integration/):\n   - issuer.test.ts: End-to-end token operations\n   - indexer.test.ts: Event processing verification\n   - corporate-actions.test.ts: Complex workflows\n3. Gas reporting:\n   - Benchmark all operations\n   - Generate GAS_REPORT.md\n   - Verify < 100k gas for transfers\n4. Documentation:\n   - README.md: Setup, usage, features\n   - ARCHITECTURE.md: System design, diagrams\n   - DECISIONS.md: Technical decision log\n   - API.md: Endpoint documentation\n   - DISCLAIMER.md: Legal/regulatory warnings\n5. Code quality:\n   - ESLint + Prettier configuration\n   - Pre-commit hooks with Husky",
        "testStrategy": "Achieve >90% code coverage, all tests passing on local and testnet, documentation reviewed for completeness, gas costs within specified targets",
        "priority": "high",
        "dependencies": [
          "2",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Write unit tests for smart contract with full coverage",
            "description": "Implement comprehensive unit tests for ChainEquityToken.sol achieving 100% code coverage, testing all contract functions, edge cases, and security scenarios",
            "dependencies": [],
            "details": "Create test/unit/ChainEquityToken.test.ts using Hardhat and Chai. Test allowlist management (approveWallet, revokeWallet), transfer restrictions with approved and non-approved addresses, minting functionality with ownership checks, virtual stock splits maintaining proportional ownership, symbol and name changes, edge cases including zero balances, maximum uint256 values, and reentrancy protection. Include negative test cases for unauthorized access and invalid parameters. Generate coverage report to ensure 100% line, branch, and function coverage.",
            "status": "done",
            "testStrategy": "Use Hardhat test framework with Chai assertions, implement beforeEach hooks for clean contract deployment, use expect.to.be.revertedWith for error testing, generate coverage report with solidity-coverage plugin",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create integration tests for backend services",
            "description": "Develop comprehensive integration tests for issuer service, indexer, and corporate actions workflows to verify end-to-end functionality",
            "dependencies": [
              1
            ],
            "details": "Implement test/integration/ directory with issuer.test.ts for testing token operations through the API, indexer.test.ts for verifying event processing and database synchronization, and corporate-actions.test.ts for complex workflows like stock splits and symbol changes. Use test fixtures with known blockchain state, mock Alchemy SDK responses where appropriate, verify database state after operations, test error recovery and retry logic, ensure proper event emission and processing flow.",
            "status": "done",
            "testStrategy": "Use Jest with supertest for API testing, create test database instances, use Sinon for mocking external services, implement test data factories for consistent test scenarios",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement gas benchmarking and reporting",
            "description": "Set up gas measurement infrastructure to benchmark all contract operations and generate detailed gas consumption reports",
            "dependencies": [
              1
            ],
            "details": "Configure Hardhat gas reporter plugin in hardhat.config.ts, create scripts/gas-benchmark.ts to systematically test gas consumption for all operations including transfers, minting, allowlist updates, and stock splits. Generate GAS_REPORT.md with tabulated results showing min/max/average gas costs per operation. Verify all standard transfers stay under 100k gas limit. Include gas optimization recommendations and comparison with standard ERC-20 implementations. Set up CI pipeline to run gas benchmarks on pull requests.",
            "status": "done",
            "testStrategy": "Use hardhat-gas-reporter for automated measurements, create benchmark scenarios with varying data sizes, compare results against gas targets defined in requirements",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Write comprehensive technical documentation",
            "description": "Create complete documentation suite including README, API documentation, architecture diagrams, and technical decision records",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Write README.md with project overview, quick start guide, installation steps, configuration instructions, and usage examples. Create ARCHITECTURE.md with system design diagrams using Mermaid, component interactions, data flow diagrams, and deployment architecture. Document all API endpoints in API.md with request/response schemas, authentication details, and example curl commands. Maintain DECISIONS.md log explaining key technical choices, trade-offs, and rationale. Add DISCLAIMER.md with legal and regulatory considerations for tokenized securities. Include code comments and JSDoc/NatSpec documentation throughout the codebase.",
            "status": "done",
            "testStrategy": "Use markdown linters for formatting consistency, validate all code examples execute correctly, ensure API documentation matches actual implementation, review for completeness and clarity",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Setup code quality tools and pre-commit hooks",
            "description": "Configure ESLint, Prettier, and Husky for automated code quality enforcement with pre-commit validation hooks",
            "dependencies": [],
            "details": "Install and configure ESLint with TypeScript parser and recommended rules for both frontend and backend code. Set up Prettier with consistent formatting rules across the project. Configure Husky to run pre-commit hooks that execute linting, formatting checks, and run unit tests before allowing commits. Add .eslintrc.js, .prettierrc, and .husky/ configuration files. Create npm scripts for linting, formatting, and fixing code issues. Add solhint for Solidity linting with security-focused rules. Configure lint-staged to only check modified files for performance.",
            "status": "done",
            "testStrategy": "Verify pre-commit hooks block commits with linting errors, test auto-formatting works correctly, ensure all existing code passes configured rules, validate CI pipeline runs same checks",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Write unit tests for smart contract with full coverage, 2) Create integration tests for backend services, 3) Implement gas benchmarking and reporting, 4) Write comprehensive technical documentation (README, API, Architecture), 5) Setup code quality tools (linting, formatting, pre-commit hooks)"
      },
      {
        "id": 11,
        "title": "Next.js Frontend Dashboard (Optional)",
        "description": "Build a web-based operator dashboard with shadcn/ui components for visual token management and cap-table viewing",
        "details": "Create Next.js 15 frontend:\n1. Setup Next.js with TypeScript and Tailwind CSS\n2. Install shadcn/ui components and Alchemy SDK\n3. Pages to implement:\n   - Home: Dashboard with stats and recent activity\n   - /approve: Wallet approval management UI\n   - /mint: Token minting interface\n   - /captable: Interactive cap-table viewer\n   - /corporate: Corporate actions interface\n4. Components:\n   - WalletConnect.tsx: Web3 wallet integration\n   - ApprovalForm.tsx: Approve/revoke interface\n   - MintForm.tsx: Token minting with validation\n   - CapTableView.tsx: Sortable/filterable table\n   - CorporateActions.tsx: Split and symbol change forms\n5. Features:\n   - Real-time updates via WebSocket\n   - Transaction status tracking\n   - Export functionality\n   - Responsive design",
        "testStrategy": "Test wallet connection flow, verify form validations, test real-time updates, ensure mobile responsiveness, validate data accuracy against backend",
        "priority": "low",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup Next.js 15 with TypeScript and Tailwind CSS",
            "description": "Initialize Next.js 15 project with TypeScript support, configure Tailwind CSS with custom theme, and set up project structure with proper linting and formatting",
            "dependencies": [],
            "details": "Create new Next.js 15 app with TypeScript template, install and configure Tailwind CSS with custom color scheme for financial dashboard, set up ESLint and Prettier configurations, create folder structure for pages, components, hooks, and utils, configure next.config.js for Web3 compatibility",
            "status": "done",
            "testStrategy": "Verify build process completes successfully, test Tailwind CSS compilation, ensure TypeScript configuration is strict, validate ESLint rules are working",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement wallet connection and Web3 integration",
            "description": "Set up Web3 wallet connectivity using WalletConnect and ethers.js, integrate with Alchemy SDK for blockchain interactions, and create reusable Web3 hooks",
            "dependencies": [
              1
            ],
            "details": "Install and configure WalletConnect v2, ethers.js, and Alchemy SDK dependencies, create WalletConnect.tsx component with MetaMask/WalletConnect support, implement custom hooks (useWallet, useContract, useBalance), set up Web3Provider context for app-wide wallet state, configure network switching between mainnet and testnets",
            "status": "done",
            "testStrategy": "Test wallet connection flow with different providers, verify network switching functionality, test transaction signing, validate Alchemy SDK integration",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create core pages (dashboard, approval, minting, cap-table)",
            "description": "Build the main application pages including home dashboard with statistics, approval management UI, token minting interface, and interactive cap-table viewer with sorting and filtering",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement Home page with stats cards showing total supply, holder count, recent activity feed, create /approve page with wallet approval/revocation interface and approved wallets list, build /mint page with form validation and transaction status tracking, develop /captable page with sortable/filterable table using tanstack-table, implement /corporate page for split and symbol change operations",
            "status": "done",
            "testStrategy": "Test page routing and navigation, verify data fetching and loading states, test form submissions and validations, ensure responsive design on all breakpoints",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build reusable components with shadcn/ui",
            "description": "Create modular, reusable components using shadcn/ui design system for forms, tables, cards, and corporate action interfaces with proper TypeScript typing",
            "dependencies": [
              1,
              2
            ],
            "details": "Install shadcn/ui components (Button, Card, Table, Form, Input, Dialog, Toast), create ApprovalForm.tsx with address validation and transaction feedback, build MintForm.tsx with amount input and recipient selection, implement CapTableView.tsx with export functionality (CSV/JSON), develop CorporateActions.tsx with split ratio and symbol change forms, add TransactionStatus component for tracking pending/confirmed transactions",
            "status": "done",
            "testStrategy": "Test component props and TypeScript types, verify form validations work correctly, test table sorting and filtering logic, ensure accessibility standards are met",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add real-time updates via WebSocket",
            "description": "Implement WebSocket connections for real-time blockchain event updates, transaction status tracking, and automatic UI refreshes when cap-table or balances change",
            "dependencies": [
              3,
              4
            ],
            "details": "Set up WebSocket connection to backend indexer service for live events, implement real-time transaction status updates with progress indicators, create event listeners for Transfer, Approval, Split, and SymbolChange events, add automatic data refetching when relevant events occur, implement connection retry logic and error handling, add notification system using toast components for important updates",
            "status": "done",
            "testStrategy": "Test WebSocket connection establishment and reconnection logic, verify real-time updates reflect in UI immediately, test error handling and fallback mechanisms, validate performance with multiple concurrent updates",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Setup Next.js 15 with TypeScript and Tailwind CSS, 2) Implement wallet connection and Web3 integration, 3) Create core pages (dashboard, approval, minting, cap-table), 4) Build reusable components with shadcn/ui, 5) Add real-time updates via WebSocket"
      },
      {
        "id": 12,
        "title": "Production Deployment and Demo Execution",
        "description": "Deploy the complete system to Polygon Amoy testnet and execute a comprehensive demonstration of all features",
        "details": "Final deployment steps:\n1. Deploy ChainEquityToken to Polygon Amoy\n2. Verify contract on Polygonscan\n3. Deploy backend services to cloud (optional):\n   - Dockerize backend services\n   - Setup persistent SQLite storage\n   - Configure environment variables\n4. Run complete demo flow:\n   - Approve 5 test wallets\n   - Mint 10,000 tokens each to 3 wallets\n   - Execute various transfers (success and blocked)\n   - Perform 7-for-1 stock split\n   - Change symbol from CEQ to CEQX\n   - Generate cap-table at each stage\n5. Create demo video/documentation:\n   - Record CLI interactions\n   - Show Polygonscan transactions\n   - Demonstrate cap-table changes\n   - Highlight compliance features\n6. Performance validation:\n   - Verify gas costs meet targets\n   - Test system under load\n   - Validate data consistency",
        "testStrategy": "Complete end-to-end system test on Polygon Amoy, verify all transactions on Polygonscan, validate cap-table accuracy, ensure demo runs without errors",
        "priority": "medium",
        "dependencies": [
          "8",
          "10"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Deploy and Verify ChainEquityToken Contract on Polygon Amoy",
            "description": "Deploy the ChainEquityToken smart contract to Polygon Amoy testnet using deployment scripts and verify it on Polygonscan for public transparency",
            "dependencies": [],
            "details": "Execute the deployment script to deploy ChainEquityToken to Polygon Amoy testnet with initial parameters (name: ChainEquity, symbol: CEQ, decimals: 18). Use the Alchemy RPC endpoint configured in hardhat.config.ts. After successful deployment, run the verification script to verify the contract on Polygonscan, ensuring constructor arguments are properly encoded. Store the deployed contract address in .env file and document deployment details including transaction hash, block number, and gas used. Confirm the contract is accessible and verified on Polygonscan explorer.",
            "status": "pending",
            "testStrategy": "Verify contract deployment transaction on Polygonscan, confirm contract is verified and source code is visible, test basic contract interactions through Polygonscan interface, validate contract address is correctly stored in environment variables",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Setup and Configure Backend Services Infrastructure",
            "description": "Prepare backend services for deployment with optional cloud hosting, including Dockerization, database persistence, and environment configuration",
            "dependencies": [
              1
            ],
            "details": "Create Docker configurations for the issuer service, indexer service, and corporate actions service if cloud deployment is desired. Set up Docker Compose file to orchestrate all services with proper networking. Configure persistent SQLite storage with volume mounts to ensure data persistence across container restarts. Set up comprehensive environment variables including Alchemy API keys, contract addresses from deployment, and database paths. For local deployment, ensure all services can run directly with npm scripts. Document both local and containerized deployment options with clear instructions for switching between them.",
            "status": "done",
            "testStrategy": "Test Docker container builds successfully, verify services start and connect to contract, validate SQLite persistence across container restarts, ensure environment variables are properly injected",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Execute Complete Demo Flow with All System Features",
            "description": "Run a comprehensive demonstration of all ChainEquity features including wallet approvals, token minting, transfers, corporate actions, and compliance blocking",
            "dependencies": [
              2
            ],
            "details": "Execute the full demo scenario step by step: First approve 5 test wallets through the issuer service CLI. Mint 10,000 CEQ tokens each to 3 approved wallets and verify balances. Execute multiple transfer scenarios including successful transfers between approved wallets and blocked transfers to non-approved addresses. Perform a 7-for-1 stock split corporate action and verify all balances are correctly multiplied. Execute symbol change from CEQ to CEQX and confirm update on-chain. Generate cap-table reports at each major step showing ownership distribution. Monitor and log all Polygonscan transactions for documentation. Ensure each operation completes successfully with reasonable gas costs.",
            "status": "pending",
            "testStrategy": "Verify each transaction on Polygonscan, validate cap-table accuracy at each stage, confirm all blocked transfers fail appropriately, ensure corporate actions execute correctly with proper event emissions",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create Demo Documentation and Validate Performance Metrics",
            "description": "Document the entire demonstration with recordings, transaction proofs, and performance validation against specified targets",
            "dependencies": [
              3
            ],
            "details": "Create comprehensive demo documentation including video recording of CLI interactions showing the complete flow from deployment through all features. Capture and document all Polygonscan transaction links with screenshots of key transactions. Create a timeline document showing cap-table evolution at each stage with visual representations. Compile gas cost analysis comparing actual costs against target benchmarks for each operation type (deployment, minting, transfers, corporate actions). Run load testing to validate system performance under stress with multiple concurrent operations. Generate a final demo report in markdown format with all metrics, links, and visual assets. Create a quick-start guide for others to reproduce the demo independently.",
            "status": "pending",
            "testStrategy": "Validate all documentation links work correctly, ensure gas costs are within 10% of targets, verify system handles at least 100 operations per minute, confirm demo can be reproduced from documentation",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Deploy and verify contract on Polygon Amoy, 2) Setup backend services (optional cloud deployment), 3) Execute comprehensive demo flow with all features, 4) Create demo documentation and validate performance metrics"
      },
      {
        "id": 13,
        "title": "Implement Historical 'As-of Block' Snapshot Feature",
        "description": "Generate on-demand historical cap-table snapshots at any given block number for auditing and compliance purposes",
        "details": "Implement historical point-in-time snapshot capability:\n1. Backend Service Enhancement:\n   - Extend captable.service.ts to support historical queries\n   - Implement on-demand computation from events table\n   - Calculate balances, ownership percentages at specific block\n   - Include historical events up to specified block\n   - Optimize queries with proper indexing\n2. CLI Command:\n   - Add new 'snapshot <block>' command\n   - Display cap-table state at specified block\n   - Support --format flag for CSV/JSON export\n   - Show ownership percentages and event history\n3. API Endpoint Enhancement:\n   - Extend GET /api/captable?block=<number>\n   - Support query parameter for block number\n   - Return historical snapshot data\n   - Include metadata (block number, timestamp)\n4. Frontend Integration:\n   - Add block number selector to captable page\n   - Support ?block=<number> URL query parameter\n   - Display historical state with visual indicators\n   - Show block timestamp and event count\n5. Data Requirements:\n   - Token holder addresses and balances at block\n   - Ownership percentages at that point in time\n   - Historical events leading to that state\n   - Account for split multipliers correctly",
        "testStrategy": "Test historical snapshot accuracy against known past states, verify ownership calculations match on-chain data, test with various block numbers including edge cases, validate query performance with large event histories, ensure split multipliers are correctly applied",
        "priority": "medium",
        "dependencies": [
          "6",
          "7",
          "9",
          "11"
        ],
        "status": "done",
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Enhance backend captable service with historical query support and event-based reconstruction, 2) Add CLI snapshot command with formatting options, 3) Extend API endpoint to support block query parameter, 4) Integrate block selector in frontend captable page",
        "subtasks": [
          {
            "id": 1,
            "title": "Enhance backend captable service with historical query support",
            "description": "Extend captable.service.ts to support historical cap-table reconstruction at any given block number using event-based balance calculation",
            "dependencies": [],
            "details": "Modify captable.service.ts to add historical snapshot capability. Implement getSnapshotAtBlock(blockNumber) method that queries the events table to reconstruct token holder balances at the specified block. Calculate ownership percentages based on total supply at that block. Properly apply split multipliers that were active at the historical block. Retrieve all relevant events (Transfer, StockSplit) up to and including the specified block. Optimize database queries with proper indexes on block_number and address fields. Add caching layer for frequently queried historical blocks. Handle edge cases like querying blocks before contract deployment or before first events.",
            "status": "done",
            "testStrategy": "Test snapshot accuracy by comparing with known historical states from blockchain, verify balance calculations match on-chain data at various blocks, test with blocks before/after stock splits, validate query performance with large event histories, ensure caching works correctly",
            "updatedAt": "2025-11-05T19:51:55.580Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement CLI snapshot command with formatting options",
            "description": "Create new 'chainequity snapshot <block>' CLI command that displays historical cap-table state with support for multiple output formats",
            "dependencies": [
              1
            ],
            "details": "Create cli/commands/snapshot.ts with snapshot command implementation. Accept block number as required argument. Add --format flag supporting 'table', 'csv', and 'json' output formats. Display token holder addresses, balances, and ownership percentages at the specified block. Show metadata including block number, block timestamp, and total event count up to that block. Format table output using cli-table3 with proper column alignment. Implement CSV export with headers (Address, Balance, Ownership %, Block Number, Timestamp). Generate JSON output with complete metadata and holder array. Add validation for block number (must be positive integer, not in future). Include error handling for blocks with no data or before token deployment.",
            "status": "done",
            "testStrategy": "Test command with various block numbers and format options, verify output accuracy against backend service, test error handling for invalid blocks, validate CSV and JSON export formats, ensure table formatting is readable",
            "parentId": "undefined",
            "updatedAt": "2025-11-05T19:57:59.608Z"
          },
          {
            "id": 3,
            "title": "Extend REST API endpoint to support block query parameter",
            "description": "Modify GET /api/captable endpoint to accept optional ?block=<number> query parameter for retrieving historical cap-table snapshots",
            "dependencies": [
              1
            ],
            "details": "Update backend/src/routes/captable.ts to handle optional 'block' query parameter. Parse and validate block number from query string. Call getSnapshotAtBlock() when block parameter is provided, otherwise return current state. Include metadata in response: block number, block timestamp, holder count, total supply. Add proper error responses for invalid block numbers (400 Bad Request). Implement response caching for historical snapshots with appropriate cache headers. Add rate limiting for historical queries to prevent abuse. Update API documentation in comments with example requests. Ensure backward compatibility - endpoint works without block parameter as before.",
            "status": "done",
            "testStrategy": "Test endpoint with and without block parameter, verify historical data accuracy, test error handling for invalid blocks, validate response format and metadata, test caching behavior, ensure backward compatibility",
            "parentId": "undefined",
            "updatedAt": "2025-11-05T20:02:45.133Z"
          },
          {
            "id": 4,
            "title": "Add block selector to frontend captable page",
            "description": "Integrate block number selector UI component on the captable page with support for ?block=<number> URL query parameter",
            "dependencies": [
              3
            ],
            "details": "Update frontend/app/captable/page.tsx to add block number input/selector component. Read ?block= query parameter from URL on page load and fetch historical data if present. Add UI input field for users to enter block number with validation (positive integers only). Implement 'View Snapshot' button that updates URL and fetches historical data. Display visual indicator showing whether viewing current or historical state (e.g., banner or badge). Show block metadata: block number, timestamp, and 'Historical Snapshot' label. Add 'Return to Current' button when viewing historical state. Update table to show historical balances and ownership percentages. Preserve existing export functionality (CSV/JSON) for historical snapshots. Ensure URL updates when selecting different blocks for shareable links.",
            "status": "done",
            "testStrategy": "Test block selector input validation, verify URL query parameter handling on page load, test historical data fetching and display, validate visual indicators for historical vs current state, ensure export works for historical snapshots, test browser back/forward navigation",
            "parentId": "undefined",
            "updatedAt": "2025-11-05T20:04:14.114Z"
          }
        ],
        "updatedAt": "2025-11-05T20:04:14.114Z"
      },
      {
        "id": 14,
        "title": "Implement Auto-Indexer for Local Development",
        "description": "Create automatic blockchain indexing service using WebSocket subscription for local development, enabling real-time database updates when new blocks are mined",
        "details": "Implement automatic indexing for local development:\n1. WebSocket Block Watcher Service:\n   - Create new service that subscribes to 'block' events via WebSocket\n   - Connect to local Hardhat node (ws://127.0.0.1:8545)\n   - Listen for new blocks in real-time\n   - Trigger indexer execution automatically on new blocks\n2. Auto-Indexer Implementation:\n   - Create backend/src/services/autoIndexer.service.ts\n   - Initialize WebSocket provider using ethers.js\n   - Subscribe to provider.on('block', callback)\n   - Execute existing indexer logic when new block detected\n   - Implement debouncing to avoid duplicate indexing\n3. CLI Command:\n   - Add new 'watch-indexer' or 'dev:watch' npm script\n   - Starts persistent process that runs alongside backend dev server\n   - Graceful shutdown on SIGINT/SIGTERM\n   - Reconnection logic for WebSocket disconnections\n4. Logging & Monitoring:\n   - Minimal logging: only show when new blocks are indexed\n   - Display block number and event count\n   - Silent mode for 'no new blocks' checks\n   - Error logging for WebSocket failures\n5. Local Development Only:\n   - Only runs when connecting to localhost:8545\n   - Add environment check to prevent running in production\n   - Documentation for local dev workflow",
        "testStrategy": "Test WebSocket connection to local Hardhat node, verify indexer runs automatically on new block events, test reconnection after WebSocket disconnection, validate that frontend shows updates immediately after transactions, ensure graceful shutdown works correctly",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create WebSocket block watcher service with ethers.js provider, 2) Implement auto-indexer logic with debouncing and existing indexer integration, 3) Add CLI command and npm script for watch-indexer, 4) Add graceful shutdown, reconnection handling, and minimal logging",
        "subtasks": [
          {
            "id": 1,
            "title": "Create WebSocket block watcher service",
            "description": "Implement WebSocket connection to local Hardhat node and subscribe to new block events using ethers.js provider",
            "dependencies": [],
            "details": "Create backend/src/services/autoIndexer.service.ts with WebSocket provider initialization. Use ethers.WebSocketProvider to connect to ws://127.0.0.1:8545. Implement provider.on('block', (blockNumber) => {}) subscription to listen for new blocks in real-time. Add environment check to only run when RPC_URL points to localhost. Include basic error handling for connection failures. Export service class with start() and stop() methods.",
            "status": "done",
            "testStrategy": "Test WebSocket connection establishes successfully to local Hardhat node, verify block subscription receives events when new blocks are mined, test that service only runs for localhost URLs"
          },
          {
            "id": 2,
            "title": "Implement auto-indexer logic with debouncing",
            "description": "Create indexer execution logic that runs automatically when new blocks are detected, with debouncing to prevent duplicate processing",
            "dependencies": [
              1
            ],
            "details": "Import and use existing indexer service from backend/src/services/indexer.service.ts. Implement block callback that triggers indexer.syncEvents() when new blocks arrive. Add debouncing logic (300-500ms) to batch rapid block production and avoid redundant indexing. Track last processed block number to prevent reprocessing. Add minimal logging that only displays when blocks are actually indexed (block number + event count). Handle indexer errors gracefully without crashing the watcher.",
            "status": "done",
            "testStrategy": "Verify indexer runs automatically when blocks are mined, test debouncing prevents duplicate indexing during rapid transactions, validate that database is updated correctly, ensure error handling doesn't crash the watcher"
          },
          {
            "id": 3,
            "title": "Add CLI command and npm script",
            "description": "Create executable script and npm command for running the auto-indexer alongside the dev server",
            "dependencies": [
              2
            ],
            "details": "Create backend/src/watch-indexer.ts as executable entry point that initializes and starts the auto-indexer service. Add shebang and ensure it's executable. Add 'watch-indexer' script to backend/package.json: 'npm run build && node dist/watch-indexer.js'. Also add to root package.json for convenience. Include helpful startup message showing connection status and instructions. Document in README how to run the watcher alongside backend dev server.",
            "status": "done",
            "testStrategy": "Test npm run watch-indexer starts successfully, verify it runs alongside npm run dev without conflicts, ensure script is executable and works from both backend and root directories"
          },
          {
            "id": 4,
            "title": "Add graceful shutdown and reconnection handling",
            "description": "Implement proper cleanup on shutdown signals and automatic reconnection logic for WebSocket disconnections",
            "dependencies": [
              2,
              3
            ],
            "details": "Add SIGINT and SIGTERM signal handlers that close WebSocket connection gracefully and exit cleanly. Display 'Shutting down auto-indexer...' message on exit. Implement WebSocket error and close event handlers. Add automatic reconnection with exponential backoff (1s, 2s, 4s, 8s max). Display connection status messages: 'Connected to local node', 'Disconnected, reconnecting in Xs', 'Reconnected successfully'. Limit reconnection attempts or provide option to disable reconnection after multiple failures.",
            "status": "done",
            "testStrategy": "Test Ctrl+C gracefully shuts down the watcher, verify reconnection works after simulated WebSocket disconnection, test exponential backoff timing, ensure multiple reconnection attempts work correctly"
          },
          {
            "id": 5,
            "title": "Audit existing indexer components and plan auto-indexer integration",
            "description": "Review current IndexerService, runner, and configs to outline integration points for the new auto-indexer service.",
            "dependencies": [],
            "details": "Inspect backend/src/services/indexer.service.ts, backend/src/indexer-runner.ts, and related configs to document hooks, database usage, and startup flow before coding.\n<info added on 2025-11-05T22:14:53.720Z>\nAudit complete: backend/src/services/indexer.service.ts already supports WebSocket and HTTP providers with auto-reconnect, exposes syncHistoricalEvents(fromBlock) backed by metadata persistence (db.setMetadata('last_synced_block')), and detects local mode via isLocalNetwork to switch into the existing HTTP polling branch (approx lines 120-170); backend/src/indexer-runner.ts stays the standalone CLI using createIndexerService with SIGTERM/SIGINT shutdown handling; backend/src/config/env.ts wires USE_LOCAL_NETWORK, LOCAL_RPC_URL (default http://127.0.0.1:8545), and TOKEN_CONTRACT_ADDRESS; backend/src/db/database.ts offers getMetadata/setMetadata for the metadata table; backend/package.json and package.json include dev:indexer and indexer scripts that drive the local nodemon/test-indexer-local flows. Plan for the auto indexer: implement backend/src/services/autoIndexer.service.ts that instantiates ethers.WebSocketProvider against ws://127.0.0.1:8545 when USE_LOCAL_NETWORK is true and the URL targets localhost, debounces provider.on('block') callbacks around 300-500ms, retrieves last_synced_block metadata before invoking IndexerService.syncHistoricalEvents(), emits only block number and processed event counts, and supply a backend/src/watch-indexer.ts CLI entry that mirrors indexer-runners graceful shutdown pattern.\n</info added on 2025-11-05T22:14:53.720Z>",
            "status": "done",
            "testStrategy": null
          },
          {
            "id": 6,
            "title": "Implement AutoIndexerService with local WebSocket block watcher",
            "description": "Create the auto indexer service that subscribes to local Hardhat blocks and triggers debounced syncs.",
            "dependencies": [
              5
            ],
            "details": "Add backend/src/services/autoIndexer.service.ts using ethers.WebSocketProvider(ws://127.0.0.1:8545), implement 300-500ms debounce, env gating for USE_LOCAL_NETWORK with localhost guard, and invoke indexer.syncHistoricalEvents.\n<info added on 2025-11-05T22:18:28.816Z>\nImplemented AutoIndexerService in backend/src/services/autoIndexer.service.ts with localhost guard, WebSocket block subscription to ws://127.0.0.1:8545, 400ms debounce, exponential backoff reconnects (1s8s, max 10 attempts), status tracking, minimal block/event logging, and start/stop lifecycle plus createAutoIndexerService() wiring to USE_LOCAL_NETWORK; IndexerService.syncHistoricalEvents() is now public in backend/src/services/indexer.service.ts and reuses either ethers.WebSocketProvider or ethers.JsonRpcProvider so the auto indexer can sync historical events against local HTTP/WebSocket endpoints without TypeScript build issues.\n</info added on 2025-11-05T22:18:28.816Z>",
            "status": "done",
            "testStrategy": "Unit-test debounce helper and environment gating logic; mock provider to ensure sync trigger calls once per block."
          },
          {
            "id": 7,
            "title": "Create CLI watcher entry and npm scripts for running auto indexer",
            "description": "Provide a CLI entrypoint and scripts to run the watcher alongside dev services with graceful shutdown.",
            "dependencies": [
              6
            ],
            "details": "Introduce backend/src/watch-indexer.ts to bootstrap AutoIndexerService, add npm scripts watch-indexer and root alias, and handle SIGINT/SIGTERM plus reconnect backoff for WebSocket drops.\n<info added on 2025-11-05T22:20:00.084Z>\nImplemented CLI watcher entry at backend/src/watch-indexer.ts:1 bootstrapping createAutoIndexerService(), printing startup guidance, validating USE_LOCAL_NETWORK/TOKEN_CONTRACT_ADDRESS, and wiring SIGTERM/SIGINT plus uncaught exception/rejection shutdown flow. Added npm scripts in backend/package.json:12 and package.json:13 so `npm run watch-indexer` works from backend (nodemon src/watch-indexer.ts) or root (`npm --prefix backend run watch-indexer`). TypeScript build passes without errors.\n</info added on 2025-11-05T22:20:00.084Z>",
            "status": "done",
            "testStrategy": "Run script against local Hardhat node, simulate SIGINT and forced provider.close to verify shutdown and reconnection behavior."
          },
          {
            "id": 8,
            "title": "Add minimal logging and local workflow documentation",
            "description": "Ensure runtime logs and docs explain the local auto-indexer behavior.",
            "dependencies": [
              6,
              7
            ],
            "details": "Implement concise logging for new block sync results and errors, add README updates describing USE_LOCAL_NETWORK flow, watcher usage, and troubleshooting for local development.\n<info added on 2025-11-05T22:21:34.623Z>\nDocumented the local auto-indexer workflow in backend/README.md with overview, setup prerequisites, usage examples, output samples, technical flow, configuration, reconnection/shutdown behavior, multi-terminal recommendations, troubleshooting, and a file-structure diagram. Confirmed minimal activity-focused logging via backend/src/services/autoIndexer.service.ts:85-134, backend/src/services/autoIndexer.service.ts:274-341, covering startup/shutdown notices, block sync summaries, and reconnection status updates.\n</info added on 2025-11-05T22:21:34.623Z>",
            "status": "done",
            "testStrategy": "Manual verification: run watcher to confirm log format, review README rendering locally."
          }
        ]
      },
      {
        "id": 15,
        "title": "Implement User-to-User Token Transfers (API, CLI, UI) with Event Classification",
        "description": "Add first-class token transfer support across backend, CLI, and frontend, with robust validation that both sender and recipient are approved. Update event indexing/history to distinguish mints (from zero address) from transfers and extend tests accordingly.",
        "details": "Scope and alignment with codebase:\n- Backend uses ethers v6 (issuer.service.ts), Express routes under backend/src/api, SQLite via better-sqlite3 (database.ts), and an event indexer (indexer.service.ts) that currently records all token movements as event_type \"Transfer\".\n- Frontend is Next.js + wagmi/viem; mint UI adjusts amounts using split multiplier. No transfer page exists. Events page lists event_type but has no \"Mint\" classification.\n- CLI (cli.ts) offers wallet and token commands (mint/balance/info) but no transfer command.\n\nImplementation Plan\n1) Backend IssuerService: transfer support and validation\n- File: backend/src/services/issuer.service.ts\n  - Add method `transferTokens(params: { to: string; amount: string; from?: string })` that:\n    - Validates `to` and `from` (if provided) with `alchemyUtils.isValidAddress`; rejects zero address and identical sender/recipient.\n    - Validates both sender and recipient are approved using `isWalletApproved` (if `from` omitted, use `this.wallet.address` as sender).\n    - Fetches `decimals` and `getSplitMultiplier()` and converts displayed amount to base units: displayedWei = parseUnits(amount, decimals); actualWei = displayedWei * 10000n / BigInt(splitMultiplier).\n    - If no `from` or `from === signer`, estimate gas and call `contract.transfer(to, actualWei)` with ~20% gas buffer.\n    - Else (delegated transfer): check `allowance(from, signer)` and if insufficient, return a clear error instructing the operator to have the sender increase allowance; then estimate gas and call `contract.transferFrom(from, to, actualWei)` with gas buffer.\n    - Return formatted TransactionReceipt using existing `formatReceipt` helper.\n  - Add helper `getSplitMultiplier()` is already present; reuse.\n  - Best practices: use ethers v6 BigInt math, reject non-retryable errors early, keep logs consistent with existing methods.\n\n2) REST API: Transfer endpoint\n- File: backend/src/api/issuer.routes.ts\n  - Add POST `/api/issuer/transfer` route with body: `{ to: string; amount: string; from?: string }`.\n  - Validate inputs (types, positive amount, address formats), ensure both sender and recipient are approved via `issuerService.isWalletApproved`, and call `issuerService.transferTokens()`.\n  - Respond with `{ success, message, data: { from, to, amount, transactionHash, blockNumber, gasUsed } }`.\n  - Errors return 400 for validation and 503 if IssuerService not initialized.\n\n3) Indexer + DB: Classify mints vs transfers\n- Files:\n  - backend/src/services/indexer.service.ts\n    - In `handleTransferEvent`, detect mint when `from === ethers.ZeroAddress` and classify event as `Mint` instead of `Transfer`.\n    - Persist `Mint` with from_address = zero address, to_address = recipient, and amount (value) unchanged.\n  - backend/src/db/schema.sql\n    - Add 'Mint' to `chk_event_type` constraint list to allow a new event_type.\n  - backend/src/types/database.ts\n    - Extend `EventType` union with `'Mint'`.\n  - backend/src/api/events.routes.ts\n    - Include 'Mint' in valid type filters, and allow `/api/events?eventType=Mint`.\n  - Migration note: For existing local DBs, provide a lightweight SQL migration (or reuse reset scripts) to reclassify rows where `event_type = 'Transfer' AND from_address = '0x0000...0000'` into `Mint`. For SQLite CHECK constraint change, recommend devs reset local DB via `reset-db-only.sh` or include a one-time migration that creates a new table with the updated CHECK, copies rows with transformed event_type, then renames tables.\n\n4) CLI: Transfer command\n- File: cli.ts\n  - Add `token transfer <to> <amount>` with optional `--from <address>` and `-n/--network`.\n  - Behavior:\n    - If `--from` omitted or equals signer, call IssuerService.transferTokens({ to, amount }).\n    - Else call IssuerService.transferTokens({ from, to, amount }). If allowance is insufficient, show a helpful message instructing the user to approve allowance first from the `from` wallet.\n    - Pre-check `isWalletApproved` for both parties and show clear errors if not approved.\n    - Output colored summary (fromto, amount, tx hash, gas used) consistent with existing CLI style. Include a spinner and friendly errors.\n\n5) Frontend: Transfer page and events labeling\n- New page: frontend/app/transfer/page.tsx\n  - UI patterned after mint page. Use `useContract`, `useTokenInfo`, `useAccount`, `useWriteContract`, `useWaitForTransactionReceipt`.\n  - Fields: recipient, amount. Use shadcn/ui `Input`, `Label`, `Button`, `Alert`.\n  - Validation: `isAddress(recipient)`, amount > 0, prevent self-transfer, prevent zero address; optionally fetch `/api/issuer/status/:address` for allowlist checks with clear error messages.\n  - Amount conversion mirrored from mint: displayedWei = parseUnits(amount, decimals); actualWei = displayedWei * 10000n / splitMultiplier; call `functionName: 'transfer'` with args `[recipient, actualWei]` (sender is connected wallet).\n  - Success alert with tx hash and auto-clear form on success (like mint page).\n- Navigation\n  - File: frontend/components/layout/Navigation.tsx: add `{ href: '/transfer', label: 'Transfer Tokens', icon: '' }` entry.\n- Events page updates\n  - File: frontend/app/events/page.tsx\n    - Add 'Mint' to `Event` type, filter select, badge coloring, and details text (e.g., \"Mint to <to> (amount symbol)\").\n\n6) Docs and DX\n- Update backend/README.md and root README.md usage sections to document new API route, CLI usage (including delegated transfer via transferFrom), and UI page.\n- Note about DB migration for event_type 'Mint' and guidance to reset local DB if needed.\n\nSecurity & Validation\n- Always validate that both sender and recipient are allowlisted via on-chain query (`isApproved`).\n- Block zero address and self-transfers.\n- For delegated transferFrom, require sufficient allowance and provide actionable feedback.\n- Keep rate-limiting middleware unchanged; reuse existing error handler patterns.\n\nReferences to codebase\n- Issuer service: backend/src/services/issuer.service.ts\n- API routes: backend/src/api/issuer.routes.ts, backend/src/api/events.routes.ts\n- Indexer: backend/src/services/indexer.service.ts\n- DB schema/types: backend/src/db/schema.sql, backend/src/types/database.ts, backend/src/db/database.ts\n- Frontend: frontend/app/mint/page.tsx (pattern), frontend/components/layout/Navigation.tsx, new frontend/app/transfer/page.tsx\n- CLI: cli.ts\n",
        "testStrategy": "Backend\n- Unit: Add tests for IssuerService.transferTokens converting amounts with split multiplier and choosing transfer vs transferFrom based on presence/value of `from` and signer equality. Mock contract methods to simulate allowance insufficient and success paths.\n- API: Add integration tests for POST /api/issuer/transfer with cases:\n  - Happy path (no `from`, signer as sender): returns 200 with receipt fields.\n  - Delegated transfer with `from` set and adequate allowance (mock success).\n  - Validation failures: missing fields, invalid addresses, amount <= 0, sender or recipient not approved.\n- Indexer/DB: In a controlled environment, insert a Transfer event with from zero address and verify the persisted `event_type` is 'Mint'; verify non-zero `from` persists as 'Transfer'. If using live indexer in tests is heavy, unit test the classification branch in `handleTransferEvent` by invoking it directly with crafted args.\n\nCLI\n- Add e2e-like tests that run `node cli.js token transfer 0x... 1.23 --network localhost` against a local Hardhat or mock provider (or stub IssuerService) to validate argument parsing, approval pre-checks, branch selection (transfer vs transferFrom), and error messages for insufficient allowance.\n\nFrontend\n- Component tests (or Playwright/Cypress if available) for the transfer page:\n  - Validates inputs, prevents submission for invalid addresses or zero amount.\n  - Converts amounts with split multiplier (mirror of mint test)  assert correct args assembled to useWriteContract via spy/mocks.\n  - Renders success and error states.\n- Events page visual test to ensure 'Mint' appears as a separate type with correct badge and details; filter by 'Mint' returns records.\n\nRegression\n- Verify existing mint flow unaffected.\n- Verify analytics and cap-table continue to reflect balances (since they already rely on contract.balanceOf which accounts for split multiplier).\n- Smoke test auto-indexer (Task 14) to ensure it continues to ingest events after classification change.\n",
        "status": "done",
        "dependencies": [
          2,
          4,
          5,
          7,
          9,
          11
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Expand Event Coverage and Indexing Tests for ChainEquityToken",
        "description": "Review and update all tests to fully cover blockchain events from ChainEquityToken, verifying correct on-chain emission, arguments, edge cases, and backend indexing. Include success and failure scenarios, and align with current indexer and API behavior.",
        "details": "Scope and alignment with codebase\n- Contract and events: `contracts/ChainEquityToken.sol:38` (WalletApproved), `contracts/ChainEquityToken.sol:41` (WalletRevoked), `contracts/ChainEquityToken.sol:44` (StockSplit), `contracts/ChainEquityToken.sol:47` (SymbolChanged), `contracts/ChainEquityToken.sol:50` (NameChanged), `contracts/ChainEquityToken.sol:53` (TransferBlocked), plus ERC20 `Transfer` and `Approval` inherited. Mint and burn surface as `Transfer` with zero address semantics.\n- Indexing: `backend/src/services/indexer.service.ts:146` classifies mints as `eventType: 'Mint'` when `from === ZeroAddress`; stores other transfers as `Transfer`. Approval is not indexed. `backend/src/services/eventListener.ts` stores Transfer/WalletApproved/WalletRevoked/StockSplit/SymbolChanged/NameChanged. DB schema supports `Transfer|Mint|WalletApproved|WalletRevoked|StockSplit|SymbolChanged|NameChanged|TransferBlocked` (backend/src/db/schema.sql:13).\n- API for verification: `backend/src/api/events.routes.ts` provides `/api/events`, `/api/events/transfers`, `/api/events/wallet-approvals`, `/api/events/corporate`, `/api/events/address/:address`.\n- Current tests: root `test/ChainEquityToken.ts` (node:test + viem) and `backend/test/ChainEquityToken.test.ts` (mocha/chai + viem) validate some flows but dont assert event args comprehensively or backend indexing.\n\nImplementation plan\n1) Contract unit tests (root hardhat tests)\n- File: update `test/ChainEquityToken.ts` to add explicit event assertions using `viem.assertions.emitWithArgs`:\n  - Transfer: normal transfer emits `Transfer(from, to, amount)` with exact args.\n  - Mint: `mint(to, amount)` emits `Transfer(0x0, to, amount)` and updates supply; also assert indexers mint classification at backend layer below.\n  - Burn: `transfer(0x0, amount)` burns if allowed by OZ v5/_update override; assert `Transfer(from, 0x0, amount)` and supply decreases. If OZ disallows, assert revert and no events (document chosen behavior).\n  - Approval: `approve(spender, amount)` emits `Approval(owner, spender, amount)` and sets allowance; add increase/decrease allowance edge tests.\n  - WalletApproved/WalletRevoked: assert emission with exact wallet arg; add idempotency: re-approve approved wallet and re-revoke revoked wallet do not emit events (receipt logs unchanged length).\n  - StockSplit: `executeSplit(multiplier)` emits with correct multiplier and `newSplitMultiplier` values; test invalid multipliers `0` and `10000` (BASIS_POINTS) revert with no events; test compounding math.\n  - SymbolChanged/NameChanged: assert exact old/new argument values and input validation (empty, symbol length > 11) reverts with no events.\n  - TransferBlocked negative: perform blocked transfer (non-allowlisted recipient or sender) and assert the transaction reverts and no events are emitted in the final receipt (clarifies that `TransferBlocked` is not observable post-revert by design). Also assert that successful transfers do not emit `TransferBlocked`.\n- Keep test style consistent with files framework (node:test + viem). Use `await viem.assertions.emitWithArgs(...)` for positive cases and `await assert.rejects(...)` for reverts, then fetch receipt/logs to confirm absence.\n\n2) Backend API/indexing tests (Jest integration)\n- Mount events router for tests: update `backend/src/__tests__/testUtils.ts:112` to include `createEventsRouter` under `/api/events` so tests can query indexed data.\n- Add new Jest integration tests:\n  - `backend/src/__tests__/integration/events.api.test.ts`:\n    - Seed DB with a realistic mix: Mint (from zero) and Transfer, WalletApproved, WalletRevoked, StockSplit, SymbolChanged, NameChanged. Use `db.insertEvent` with event_type mirroring indexer outputs (Mint vs Transfer). Verify `/api/events` pagination and `/api/events?eventType=Mint|Transfer|WalletApproved|WalletRevoked|StockSplit|SymbolChanged|NameChanged` return correct types, fields, and sort order.\n    - Verify `/api/events/address/:address` aggregates events for a specific address and excludes unrelated events.\n    - Assert API rejects invalid `eventType` (Approval or Burn) with 400, reflecting current schema.\n  - `backend/src/__tests__/integration/indexer.classification.test.ts`:\n    - If feasible in CI, spin up local Hardhat node and deploy `ChainEquityToken` (reusing hardhat/viem). Start a short-lived `IndexerService` (backend/src/services/indexer.service.ts) against `config.useLocalNetwork=true` and the deployed contract.\n    - Execute: approve two wallets, mint to wallet A, transfer A->B, symbolic change and stock split, attempt blocked transfer (expected revert). Wait for indexer to insert. Assertions against DB (via `db.getAllEvents`) and API:\n      - Mint appears as `event_type: 'Mint'` with `from_address` zero and correct amount.\n      - Transfer appears as `event_type: 'Transfer'` with proper addresses and amount.\n      - No `TransferBlocked` record exists for the failed transfer (revert rolls back logs), and no extraneous events on failure paths.\n      - Corporate actions are present in both `events` and `corporate_actions` with correct metadata.\n- Keep DB isolation per test using `createTestDatabase()` and `cleanupTestDatabase()`.\n\n3) Mocha/Chai test alignment (backend/test)\n- In `backend/test/ChainEquityToken.test.ts`, replace generic logs length > 0 checks with explicit decoding and argument assertions for the same event matrix as root tests, matching that files Mocha/Chai style. Ensure consistency of expectations for negative cases (no events on revert; idempotent state operations dont emit).\n\n4) Documentation and fixtures\n- Add brief comments in tests explaining zero-address semantics: Mint = Transfer from zero; Burn = Transfer to zero (if allowed by underlying OZ v5). Note that Approval and Burn are not indexed by backend by design; covered at on-chain level only.\n- Where event types diverge between on-chain and backend classification (Mint vs Transfer), assert both layers appropriately: on-chain Transfer(from=0x0,...) and backend `event_type: 'Mint'`.\n\nKey references for implementation\n- Contract: `contracts/ChainEquityToken.sol:141`, `contracts/ChainEquityToken.sol:175`, `contracts/ChainEquityToken.sol:243`, `contracts/ChainEquityToken.sol:271`.\n- Indexer: `backend/src/services/indexer.service.ts:146`, `backend/src/services/indexer.service.ts:496` saveEvent, `backend/src/services/indexer.service.ts:567` sync historical, `backend/src/services/eventListener.ts:24` subscriptions.\n- API: `backend/src/api/events.routes.ts:16` all events endpoint and `eventType` validation.\n- DB schema: `backend/src/db/schema.sql:13` event type check.\n\nNotes on non-existent events in this codebase\n- ComplianceOfficerAdded/ComplianceOfficerRemoved are not present in the current ABI or indexer. Add negative tests that confirm these topics are absent in the contract ABI and that API validation rejects them as event types. If these roles are added in the future, expand both contract and indexer plus DB schema before enabling positive tests.\n",
        "testStrategy": "Verification checklist\n- Unit (Hardhat) tests\n  - Run `npm test`.\n  - Confirm new tests in `test/ChainEquityToken.ts` pass and assert exact event args for: Transfer, Mint (as Transfer from zero), Burn (Transfer to zero if supported), Approval, WalletApproved, WalletRevoked, StockSplit, SymbolChanged, NameChanged. Validate negative cases: blocked transfers and invalid inputs do not emit events.\n  - Ensure idempotent approve/revoke do not emit duplicate events (compare log counts or use viem assertions for non-emission by executing and checking receipt logs length unchanged).\n- Backend integration (Jest)\n  - Run `npm --prefix backend test`.\n  - events.api.test: Validate `/api/events` returns correct types, fields, pagination, and filtering; verify address-scoped queries; confirm invalid event type (Approval/Burn/ComplianceOfficer*) returns 400.\n  - indexer.classification.test (if enabled): Start local Hardhat + IndexerService, perform mint/transfer/split/symbol flows, then assert DB contains: Mint events for zero-from transfers, Transfer events for normal transfers, WalletApproved/Revoked, StockSplit, SymbolChanged/NameChanged, and no TransferBlocked entries for reverted txs. Verify values, addresses, and block/timestamp presence.\n- Cross-layer consistency\n  - For mint operations, assert both on-chain Transfer(from=zero) and backend `event_type: 'Mint'` exist and agree on amount and addresses.\n  - For burn (if supported), assert backend records it as `Transfer` with `to_address` zero (no separate Burn type).\n- Coverage and regression\n  - Ensure new tests raise coverage around event logic paths and failure scenarios. Run `run-tests.sh` to execute both suites locally. Track flakiness by avoiding timing assumptions; use DB seeding or explicit waits for indexer e2e.\n",
        "status": "pending",
        "dependencies": [
          3,
          5,
          9,
          15
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Repository scan to locate contracts, backend, API, DB, and test files",
            "description": "List and confirm locations of ChainEquityToken contract, indexer service, event listener, events API routes, DB schema, and both root and backend tests to align planned coverage with actual code.",
            "dependencies": [],
            "details": "Use ripgrep to enumerate files: contracts/ChainEquityToken.sol, test/ChainEquityToken.ts, backend/src/services/indexer.service.ts, backend/src/services/eventListener.ts, backend/src/api/events.routes.ts, backend/src/db/schema.sql, backend/test/ChainEquityToken.test.ts, and any backend/src/__tests__ integration tests. Capture paths for follow-up reads.",
            "status": "pending",
            "testStrategy": "Verify file existence and note their paths; record key line anchors to speed subsequent reads."
          },
          {
            "id": 2,
            "title": "Grep event names across codebase to map declarations and usage",
            "description": "Search for WalletApproved, WalletRevoked, StockSplit, SymbolChanged, NameChanged, TransferBlocked, Transfer, and Approval to identify Solidity declarations and backend handlers.",
            "dependencies": [
              1
            ],
            "details": "Use ripgrep on contracts/ and backend/src/ to find event definitions, indexer classification points (e.g., Mint when from==ZeroAddress), and API validation for event types. Note line numbers for primary references.",
            "status": "pending",
            "testStrategy": "Produce a quick reference of matches (file:line) to guide precise assertions in tests."
          },
          {
            "id": 3,
            "title": "Read key implementation files to understand semantics and indexing",
            "description": "Open and review ChainEquityToken.sol and backend indexer/API/schema to confirm event payloads, classification rules, and exposed endpoints.",
            "dependencies": [
              2
            ],
            "details": "Examine: contracts/ChainEquityToken.sol around lines 3860 and functional sections; backend/src/services/indexer.service.ts (Mint vs Transfer classification, saveEvent), backend/src/services/eventListener.ts (subscriptions), backend/src/api/events.routes.ts (routes and validators), backend/src/db/schema.sql (event_type CHECK and corporate tables).",
            "status": "pending",
            "testStrategy": "Summarize behaviors: which events are emitted on-chain, which are stored/indexed, and which are accessible via API; align planned tests accordingly."
          },
          {
            "id": 4,
            "title": "Add unit tests for ERC20 Transfer and Mint (zero-address source) classification",
            "description": "Expand root Hardhat tests to assert exact Transfer args and cover Mint as Transfer from zero; prepare backend expectations for Mint classification.",
            "dependencies": [
              3
            ],
            "details": "In test/ChainEquityToken.ts, add viem emitWithArgs assertions for: normal Transfer, Mint emitting Transfer(0x0,to,amount); verify totalSupply changes. Plan backend integration to expect event_type Mint when from==ZeroAddress.",
            "status": "pending",
            "testStrategy": "Run unit tests; in backend integration, seed DB and assert /api/events and /api/events/transfers reflect Mint vs Transfer properly."
          },
          {
            "id": 5,
            "title": "Expand Approval tests including allowance edge cases; assert non-indexing",
            "description": "Add Approval event assertions and increase/decrease allowance edge cases; ensure backend/API does not accept Approval as eventType.",
            "dependencies": [
              3
            ],
            "details": "In test/ChainEquityToken.ts, assert Approval(owner,spender,amount) and allowance updates; include zero and max values. In backend tests, expect 400 for eventType=Approval and confirm schema lacks Approval type.",
            "status": "pending",
            "testStrategy": "On-chain: emitWithArgs and state checks. Backend: API request with eventType=Approval returns 400 and no DB records."
          },
          {
            "id": 6,
            "title": "Cover Burn semantics (Transfer to zero) or revert and negative indexing",
            "description": "Implement tests for burn behavior via Transfer to zero if supported, or assert revert with no events; confirm backend has no Burn event type.",
            "dependencies": [
              3
            ],
            "details": "In unit tests, attempt burn and validate either Transfer(to=0x0) with supply decrease or revert + no logs; document OZ-based behavior. Backend integration confirms schema/API rejects Burn as eventType.",
            "status": "pending",
            "testStrategy": "Check receipt logs length and topics on-chain; assert API 400 for eventType=Burn and absence in DB."
          },
          {
            "id": 7,
            "title": "Test WalletApproved and WalletRevoked events including idempotency",
            "description": "Ensure allowlist events emit with correct args and that re-approving/re-revoking does not emit additional logs.",
            "dependencies": [
              3
            ],
            "details": "Unit tests: emitWithArgs for both events, then repeat calls and verify receipt logs unchanged length. Backend tests: seed and query /api/events/wallet-approvals and validate payloads and counts.",
            "status": "pending",
            "testStrategy": "On-chain: strict arg assertions + unchanged log count on idempotent operations. Backend: API returns only unique events as seeded."
          },
          {
            "id": 8,
            "title": "Comprehensive StockSplit tests with invalid multipliers and compounding",
            "description": "Assert StockSplit event args, state changes, and that invalid multipliers revert without emitting events; test compounding math across multiple splits.",
            "dependencies": [
              3
            ],
            "details": "Unit tests: valid multiplier emits with correct values and updates splitMultiplier; invalid 0 and max/BASIS_POINTS reverts. Backend tests: events show under /api/events and corporate endpoints with correct metadata.",
            "status": "pending",
            "testStrategy": "On-chain: emitWithArgs and post-state checks; Backend: API returns corporate action rows with expected fields and ordering."
          },
          {
            "id": 9,
            "title": "Validate SymbolChanged and NameChanged events and input constraints",
            "description": "Assert old/new values in events, state updates, and rejections for invalid inputs (empty name, symbol length > 11) without events.",
            "dependencies": [
              3
            ],
            "details": "Unit tests: emitWithArgs for symbol and name changes, then negative cases with revert + no logs. Backend tests: corporate endpoints include these events and exclude invalid ones.",
            "status": "pending",
            "testStrategy": "On-chain: event args + state validation; Backend: query /api/events/corporate and check records present with correct data."
          },
          {
            "id": 10,
            "title": "Confirm TransferBlocked behavior: no logs on revert; none on success",
            "description": "Test that blocked transfers revert and do not leave observable TransferBlocked logs; successful transfers never emit TransferBlocked.",
            "dependencies": [
              3
            ],
            "details": "Unit tests: attempt non-allowlisted transfer -> assert revert + no logs; allowed transfer -> only Transfer event. Backend: verify schema allows TransferBlocked type but indexer/API do not produce it on reverted txs.",
            "status": "pending",
            "testStrategy": "Inspect transaction receipt logs; query backend DB/API for absence of TransferBlocked entries for failed txs."
          },
          {
            "id": 11,
            "title": "Negative tests for non-existent ComplianceOfficer events and API validation",
            "description": "Ensure ComplianceOfficerAdded/Removed are absent in ABI and that API rejects them as event types, maintaining alignment with current schema and indexer.",
            "dependencies": [
              3
            ],
            "details": "Grep ABI and contracts to confirm absence; backend tests request /api/events?eventType=ComplianceOfficerAdded/Removed and expect 400 due to validation and schema constraints.",
            "status": "pending",
            "testStrategy": "Contract grep returns no matches; API responds 400 with validation error; no DB rows for these types."
          }
        ]
      },
      {
        "id": 17,
        "title": "Frontend Accordion for Approved Wallets",
        "description": "Add a collapsible Accordion under the Manage Wallet UI that lists all approved wallet addresses, integrates with the existing approved wallets API, supports search/filter, copy-to-clipboard, and optional approval timestamps with a \"recently added\" indicator.",
        "details": "Context and stack: Next.js App Router (frontend/), React 19, Tailwind, shadcn/ui components, lucide-react icons, wagmi. Data fetching uses React Query via QueryClientProvider (see frontend/components/providers.tsx). Backend exposes REST endpoints including GET /api/issuer/approved and events endpoints (see backend/src/api/issuer.routes.ts and backend/src/api/events.routes.ts). Use NEXT_PUBLIC_API_URL (fallback http://localhost:4000) for API base (see patterns in frontend/app/transfer/page.tsx and components/sections/MintSection.tsx). Implementation plan:\n\n1) Component structure\n- Create client component frontend/components/sections/ApprovedWalletsAccordion.tsx (\"use client\").\n- Render a Card with a header row that toggles expand/collapse (local state `isOpen`). Include count and Chevron icon from lucide-react.\n- When open, show: search input, results summary, paginated list (table) of addresses with copy-to-clipboard per row, and optional approval timestamps.\n\n2) Data fetching\n- Use React Query for data:\n  - useQuery(['approvedWallets'], () => fetch(`${API_URL}/api/issuer/approved`).then(r => r.json())) with `staleTime: 60_000`, `refetchInterval: 10_000` to reflect near real-time changes (compatible with auto-indexer).\n  - Shape: { success: true, data: { wallets: string[], count: number } } per backend/src/api/issuer.routes.ts.\n- Optional timestamps: Fetch recent approval/revocation events to compute approval timestamps for listed wallets:\n  - useQuery(['walletApprovalEvents', approvedCount], () => fetch(`${API_URL}/api/events/wallet-approvals?limit=${Math.max(approvedCount*4, 200)}`).then(r => r.json()), { enabled: approvedCount > 0 }).\n  - Events shape per backend/src/api/events.routes.ts and db schema (backend/src/db/schema.sql): each event has event_type ('WalletApproved'/'WalletRevoked'), to_address (approved wallet for approvals), from_address (revoked wallet for revocations), timestamp.\n  - Build a Map<string, number> approvedAt by iterating events newestoldest: for each address that is in the current approved set, assign its latest WalletApproved.timestamp and skip if we encounter a WalletRevoked after that.\n\n3) UI/UX details\n- Place the Accordion below the existing Manage Wallet Card and informational Alert in frontend/app/approve/page.tsx by importing and rendering <ApprovedWalletsAccordion />.\n- Use shadcn/ui components for consistency:\n  - Card, CardHeader, CardContent, Button, Input, Badge, Table, Pagination (reuse frontend/components/ui/pagination.tsx).\n  - Icons: ChevronDown/ChevronRight for expand state, Copy for copy-to-clipboard, optional Clock for timestamps.\n- Search/filter: Add a text Input above the list. Implement case-insensitive substring matching; debounce input by ~300ms via useEffect + setTimeout. Memoize filtered results with useMemo.\n- Pagination: Client-side paginate filtered results, default 50 per page. Use existing Pagination component and show totalItems from backend count. Maintain controlled state: currentPage, itemsPerPage.\n- Copy-to-clipboard: Use the pattern from frontend/components/sections/DashboardSection.tsx (navigator.clipboard.writeText + local \"\" confirmation or a sonner toast). Provide aria-label on the copy Button.\n- Formatting: Display addresses monospace, truncated (0x1234abcd) with full copy support. Include a small Badge or dot indicator (e.g., green \"New\") for addresses with approvedAt within last 24h.\n- Loading and error states: Show a lightweight skeleton or text placeholders while queries load. Show an Alert on error with retry button (queryClient.invalidateQueries).\n- Accessibility: The toggle Button sets aria-expanded and aria-controls; ensure focus styles on interactive elements; tab-order friendly controls.\n- Performance: Avoid re-computing filters and maps via useMemo; cancel in-flight fetch via AbortController; avoid rendering full list by paginating. Do not add new packages.\n\n4) File changes\n- Add: frontend/components/sections/ApprovedWalletsAccordion.tsx implementing the above UI.\n- Update: frontend/app/approve/page.tsx to import and render ApprovedWalletsAccordion below the existing Alert, maintaining current styling.\n- Optional (if preferred): Add a tiny wrapper in frontend/components/ui/accordion.tsx for consistent semantics, but not required since package installs are restricted; a simple stateful collapse is acceptable.\n\n5) Types and utilities\n- Define a local TypeScript type for the approved wallets response: type ApprovedWalletsResponse = { success: boolean; data: { wallets: string[]; count: number } }.\n- Utility helpers: formatAddress(addr) => `${addr.slice(0,6)}...${addr.slice(-4)}`. Reuse copy UX approach from DashboardSection.\n\n6) Acceptance criteria\n- Accordion renders under Manage Wallet on /approve and toggles open/closed.\n- When open, it fetches and displays the list of approved addresses with total count.\n- Search and pagination work together and performantly on large lists.\n- Copy-to-clipboard works with clear visual feedback.\n- If approval event data is available, each row optionally shows \"Approved at\" (local time) and a \"New\" indicator for the last 24h.\n- Graceful loading, empty, and error states.\n- No new external dependencies introduced.\n",
        "testStrategy": "Manual and integration verification without new dependencies:\n\nEnvironment setup\n- Start backend and indexer (ensure events are being recorded):\n  - In backend/: `npm install` (if not already), `npm run dev` (default port 4000). Confirm /api/issuer/approved and /api/events/wallet-approvals respond.\n- Start frontend: In frontend/: `npm install` (if not already), `npm run dev` (default port 3050), with NEXT_PUBLIC_API_URL=http://localhost:4000.\n\nFunctional checks on /approve\n1) Placement and basic UX\n- Confirm the Accordion appears under the Manage Wallet card and Alert.\n- Toggle expand/collapse; verify aria-expanded updates and content mounts/unmounts.\n\n2) Data loading and list rendering\n- With no approved wallets, verify an empty state message and count=0.\n- Approve a few wallets (via API: POST /api/issuer/approve or CLI/script), refresh or wait for auto-refetch; confirm addresses appear, count matches backend.\n\n3) Search/filter and pagination\n- Approve >60 wallets (or simulate by adding many locally if available). Verify default page shows 50 items, pagination controls navigate pages correctly, and count text updates.\n- Use the search input to filter by substring; verify debounce (~300ms) and that pagination re-calculates over filtered results.\n\n4) Copy-to-clipboard and formatting\n- Click copy icon on a row; verify clipboard contains the full address. Confirm UI feedback ( or toast) displays and clears after ~2s.\n- Verify truncated display format matches 0xNNNNNNNN while copying the full address.\n\n5) Approval timestamps and New indicator\n- After approving a wallet, verify approvedAt shows (if events endpoint returns data) and that a New indicator appears within 24h, disappearing after the threshold or on older entries.\n- Revoke a wallet and re-approve; verify timestamps reflect the latest approval and the address only appears when approved.\n\n6) Error and loading states\n- Temporarily stop backend or point API URL incorrectly; verify error Alert with retry is shown.\n- Restore backend; verify successful refetch restores list.\n\n7) Accessibility and responsiveness\n- Navigate with keyboard (Tab, Enter/Space on toggle). Confirm focus ring visibility and accessible labels (copy button, toggle button). Check on mobile viewport that layout wraps correctly and table remains readable.\n",
        "status": "pending",
        "dependencies": [
          9,
          11
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-05T20:04:14.115Z",
      "taskCount": 14,
      "completedCount": 11,
      "tags": [
        "master"
      ],
      "created": "2025-11-05T22:01:04.500Z",
      "description": "Tasks for master context",
      "updated": "2025-11-09T23:55:32.571Z"
    }
  }
}